[{"categories":["Golang"],"content":"介绍 golang提供了文件相关的各种操作，包括创建、删除、和读写等。 ","date":"2021-06-06","objectID":"/golang_file/:1:0","tags":["Golang","file"],"title":"golang文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"文件基本操作方法 ","date":"2021-06-06","objectID":"/golang_file/:2:0","tags":["Golang","file"],"title":"golang文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"1. 查看文件信息 func main() { // 查看文件信息 fileInfo, err := os.Stat(\"./data.txt\") if err != nil { fmt.Println(err) return } fmt.Println(\"Stat:\", fileInfo.Name()) fmt.Println(\"Stat:\", fileInfo.IsDir()) fmt.Println(\"Stat:\", fileInfo.Size()) fmt.Println(\"Stat:\", fileInfo.Mode()) fmt.Println(\"Stat:\", fileInfo.ModTime()) } ","date":"2021-06-06","objectID":"/golang_file/:2:1","tags":["Golang","file"],"title":"golang文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"2. 路径操作 func main() { // 路径操作 filename1 := \"./file.txt\" fmt.Println(\"IsAbs:\", filepath.IsAbs(filename1)) // 获取绝对路径 fileabs, err := filepath.Abs(filename1) if err != nil { log.Fatal(err) } fmt.Println(fileabs) // 绝对路径的父级目录 fmt.Println(\"Join:\", path.Join(fileabs, \"..\")) } ","date":"2021-06-06","objectID":"/golang_file/:2:2","tags":["Golang","file"],"title":"golang文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"3. 创建一级文件夹 func main() { // 创建一级文件夹 err := os.Mkdir(\"./aa\", os.ModePerm) if err != nil { fmt.Println(err) } } ","date":"2021-06-06","objectID":"/golang_file/:2:3","tags":["Golang","file"],"title":"golang文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"4. 创建多级文件夹 func main() { // 创建多级文件夹 err := os.MkdirAll(\"./bb/cc\", os.ModePerm) if err != nil { fmt.Println(err) } } ","date":"2021-06-06","objectID":"/golang_file/:2:4","tags":["Golang","file"],"title":"golang文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"5. 创建文件 func main() { // 创建文件，权限默认为0666，如果文件存在，会清空数据 file, err := os.Create(\"./file.txt\") if err != nil { fmt.Println(err) return } file.Close() } ","date":"2021-06-06","objectID":"/golang_file/:2:5","tags":["Golang","file"],"title":"golang文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"5. 只读模式打开文件 func main() { // 只读模式打开文件 file, err := os.Open(\"./file.txt\") if err != nil { fmt.Println(err) return } file.Close() } ","date":"2021-06-06","objectID":"/golang_file/:2:6","tags":["Golang","file"],"title":"golang文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"6. 以指定模式打开文件 func main() { // 以指定模式打开文件，如果文件不存在，则以指定权限0666创建文件 file, err := os.OpenFile(\"./file.txt\", os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0666) if err != nil { fmt.Println(err) return } file.Close() } ","date":"2021-06-06","objectID":"/golang_file/:2:7","tags":["Golang","file"],"title":"golang文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"7. 删除空目录或文件 func main() { // 删除空目录 err := os.Remove(\"./aa\") if err != nil { fmt.Println(\"remove:\", err) return } // 删除文件 err = os.Remove(\"./file.txt\") if err != nil { fmt.Println(\"remove:\", err) return } } ","date":"2021-06-06","objectID":"/golang_file/:2:8","tags":["Golang","file"],"title":"golang文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"8. 删除指定目录或文件，即使目录非空 func main() { // 删除所有目录，包括非空目录 err := os.RemoveAll(\"./aa.txt\") if err != nil { fmt.Println(\"RemoveAll:\", err) return } err = os.RemoveAll(\"./data.txt\") if err != nil { fmt.Println(\"RemoveAll:\", err) return } } ","date":"2021-06-06","objectID":"/golang_file/:2:9","tags":["Golang","file"],"title":"golang文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"读取文件内容 除了上述的文件基本操作外，golang还为读文件提供了多种方式。 ","date":"2021-06-06","objectID":"/golang_file/:3:0","tags":["Golang","file"],"title":"golang文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"file.Read func main() { file, err := os.Open(\"./data.txt\") if err != nil { log.Fatal(err) } defer file.Close() b := make([]byte, 128) for { n, err := file.Read(b) if err == io.EOF { break } if err != nil { log.Fatal(err) } fmt.Printf(\"%s\", string(b[:n])) } } ","date":"2021-06-06","objectID":"/golang_file/:3:1","tags":["Golang","file"],"title":"golang文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"io.ReadFull 1 package main 2 3 import ( 4 \"fmt\" 5 \"io\" 6 \"log\" 7 \"os\" 8 ) 9 10 func main() { 11 file, err := os.Open(\"./data.txt\") 12 if err != nil { 13 log.Fatal(err) 14 } 15 defer file.Close() 16 17 // 读取正好1024个字节，内容不够会报错 18 b := make([]byte, 1024) 19 n, err := io.ReadFull(file, b) 20 if err != nil { 21 log.Fatal(err) 22 } 23 24 fmt.Printf(\"%s\", string(b[:n])) 25 } ","date":"2021-06-06","objectID":"/golang_file/:3:2","tags":["Golang","file"],"title":"golang文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"io.ReadAtLeast func main() { file, err := os.Open(\"./data.txt\") if err != nil { log.Fatal(err) } defer file.Close() // 至少读取8个字节，不够的话会报错 b := make([]byte, 1024) n, err := io.ReadAtLeast(file, b, 8) if err != nil { log.Fatal(err) } fmt.Printf(\"%s\", string(b[:n])) } ","date":"2021-06-06","objectID":"/golang_file/:3:3","tags":["Golang","file"],"title":"golang文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"bufio.NewReader bufio提供了多种读取文件的方法，但方法名都是以Read开头。 func main() { file, err := os.Open(\"./data.txt\") if err != nil { log.Fatal(err) } defer file.Close() reader := bufio.NewReader(file) for { str, err := reader.ReadString('\\n') if err == io.EOF { break } if err != nil { log.Fatal(err) } fmt.Printf(\"%s\", str) } } ","date":"2021-06-06","objectID":"/golang_file/:3:4","tags":["Golang","file"],"title":"golang文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"ioutil.ReadAll func main() { file, err := os.Open(\"./data.txt\") if err != nil { log.Fatal(err) } defer file.Close() data, err := ioutil.ReadAll(file) if err != nil { log.Fatal(err) } fmt.Printf(\"%s\", string(data)) } ","date":"2021-06-06","objectID":"/golang_file/:3:5","tags":["Golang","file"],"title":"golang文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"ioutil.ReadFile func main() { b, err := ioutil.ReadFile(\"./data.txt\") if err != nil { log.Fatal(err) } fmt.Println(string(b)) } ","date":"2021-06-06","objectID":"/golang_file/:3:6","tags":["Golang","file"],"title":"golang文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"bufio.NewScanner func main() { file, err := os.Open(\"./data.txt\") if err != nil { log.Fatal(err) } defer file.Close() scanner := bufio.NewScanner(file) for scanner.Scan() { fmt.Println(scanner.Text()) } err = scanner.Err() if err != nil { log.Fatal(err) } } ","date":"2021-06-06","objectID":"/golang_file/:3:7","tags":["Golang","file"],"title":"golang文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"写入文件 golang为写文件提供了以下方式。 ","date":"2021-06-06","objectID":"/golang_file/:4:0","tags":["Golang","file"],"title":"golang文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"file.Write func main() { file, err := os.OpenFile(\"./data.txt\", os.O_WRONLY|os.O_CREATE, 0644) if err != nil { log.Fatal(err) } defer file.Close() b := []byte(\"Hello\") n, err := file.Write(b) if err != nil { log.Fatal(err) } fmt.Printf(\"Wrote %d bytes.\\n\", n) } ","date":"2021-06-06","objectID":"/golang_file/:4:1","tags":["Golang","file"],"title":"golang文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"ioutil.WriteFile func main() { err := ioutil.WriteFile(\"./data.txt\", []byte(\"Hello\"), 0644) if err != nil { log.Fatal(err) } } ","date":"2021-06-06","objectID":"/golang_file/:4:2","tags":["Golang","file"],"title":"golang文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"bufio.NewWriter bufio包中，写入文件的方法较多，但都是以Write开头。 func main() { file, err := os.OpenFile(\"./data.txt\", os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644) if err != nil { log.Fatal(err) } defer file.Close() writer := bufio.NewWriter(file) writer.WriteString(\"Hello world\") writer.Flush() } ","date":"2021-06-06","objectID":"/golang_file/:4:3","tags":["Golang","file"],"title":"golang文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"定义 Buffer是一个可变长的字节缓冲区，具备读写的方法。Buffer的零值是一个空的缓冲区。 type Buffer struct { buf []byte // contents are the bytes buf[off : len(buf)] off int // read at \u0026buf[off], write at \u0026buf[len(buf)] lastRead readOp // last read operation, so that Unread* can work correctly. } ","date":"2021-06-06","objectID":"/golang_buffer_pkg/:1:0","tags":["Golang","buffer"],"title":"golang buffer包的使用","uri":"/golang_buffer_pkg/"},{"categories":["Golang"],"content":"声明 有四种声明方法。 直接定义一个Buffer变量。 var b bytes.Buffer 使用New返回Buffer变量指针。 b := new(bytes.Buffer) 使用[]byte切片初始化。 b := bytes.NewBuffer([]byte(\"hello\")) 使用string初始化。 b := bytes.NewBufferString(\"hello\") ","date":"2021-06-06","objectID":"/golang_buffer_pkg/:2:0","tags":["Golang","buffer"],"title":"golang buffer包的使用","uri":"/golang_buffer_pkg/"},{"categories":["Golang"],"content":"写数据 Buffer提供了5种写数据的方法。 将[]byte切片写入尾部。 func (b *Buffer) Write(p []byte) (n int, err error) 将string写入尾部。 func (b *Buffer) WriteString(s string) (n int, err error) 将字符写入尾部。 func (b *Buffer) WriteByte(c byte) error 将rune写入尾部。 func (b *Buffer) WriteRune(r rune) (n int, err error) 将接口对象写入尾部。 func (b *Buffer) ReadFrom(r io.Reader) (n int64, err error) ","date":"2021-06-06","objectID":"/golang_buffer_pkg/:3:0","tags":["Golang","buffer"],"title":"golang buffer包的使用","uri":"/golang_buffer_pkg/"},{"categories":["Golang"],"content":"读数据 Buffer提供了7种读数据的方法。 读取n个字符。 func (b *Buffer) Next(n int) []byte 将数据读入[]byte。 func (b *Buffer) Read(p []byte) (n int, err error) 读取第一个byte。 func (b *Buffer) ReadByte() (byte, error) 读取第一个UTF8编码字符。 func (b *Buffer) ReadRune() (r rune, size int, err error) 读取分隔符前的内容，并且返回切片。 func (b *Buffer) ReadBytes(delim byte) (line []byte, err error) 读取分隔符前的内容，并且返回字符串。 func (b *Buffer) ReadString(delim byte) (line string, err error) 将内容输出到接口对象。 func (b *Buffer) WriteTo(w io.Writer) (n int64, err error) ","date":"2021-06-06","objectID":"/golang_buffer_pkg/:4:0","tags":["Golang","buffer"],"title":"golang buffer包的使用","uri":"/golang_buffer_pkg/"},{"categories":["Golang"],"content":"其他方法 返回字节切片。 func (b *Buffer) Bytes() []byte 返回字节切片容量。 func (b *Buffer) Cap() int 为容量增加n个字节。 func (b *Buffer) Grow(n int) 返回缓冲区长度。 func (b *Buffer) Len() int 清空数据。 func (b *Buffer) Reset() 字符串化。 func (b *Buffer) String() string 丢弃前n个未读字节以外的数据。 func (b *Buffer) Truncate(n int) 将最后一次成功读取的字节，设为未读取状态。 func (b *Buffer) UnreadByte() error 将最后一次读取的rune字符，设为未读取状态。 func (b *Buffer) UnreadRune() error ","date":"2021-06-06","objectID":"/golang_buffer_pkg/:5:0","tags":["Golang","buffer"],"title":"golang buffer包的使用","uri":"/golang_buffer_pkg/"},{"categories":["Golang"],"content":"bufio包介绍 bufio包可以从文件或标准输入读取数据，还可以向文件中写入数据。 读取数据时，先将数据读入缓冲区，然后再从缓冲区中读取。写入数据时，先把数据写入缓冲区，然后在某个时间节点，一次性地将数据写入文件。 通过缓冲区，能有效减少读写磁盘的次数。 ","date":"2021-06-06","objectID":"/golang_bufio_pkg/:1:0","tags":["Golang","bufio"],"title":"golang bufio包的使用","uri":"/golang_bufio_pkg/"},{"categories":["Golang"],"content":"使用 下面仅介绍一些常见用法。 ","date":"2021-06-06","objectID":"/golang_bufio_pkg/:2:0","tags":["Golang","bufio"],"title":"golang bufio包的使用","uri":"/golang_bufio_pkg/"},{"categories":["Golang"],"content":"1. 读取数据 func main() { file1, err := os.OpenFile(\"./data.txt\", os.O_CREATE|os.O_RDWR, os.ModePerm) if err != nil { log.Fatal(err) } defer file1.Close() // 创建缓冲区，默认大小是4096 buf := bufio.NewReader(file1) b := make([]byte, 64) n, err := buf.Read(b) if err != nil { log.Fatal(err) } fmt.Println(buf.Buffered()) fmt.Println(string(b[:n])) } ","date":"2021-06-06","objectID":"/golang_bufio_pkg/:2:1","tags":["Golang","bufio"],"title":"golang bufio包的使用","uri":"/golang_bufio_pkg/"},{"categories":["Golang"],"content":"2. 按行读取 func main() { file1, err := os.OpenFile(\"./data.txt\", os.O_CREATE|os.O_RDWR, os.ModePerm) if err != nil { log.Fatal(err) } defer file1.Close() // 创建缓冲区，默认大小是4096 buf := bufio.NewReader(file1) // 按行读取 for { bs1, _, err := buf.ReadLine() if err == io.EOF { break } fmt.Println(string(bs1)) } } ","date":"2021-06-06","objectID":"/golang_bufio_pkg/:2:2","tags":["Golang","bufio"],"title":"golang bufio包的使用","uri":"/golang_bufio_pkg/"},{"categories":["Golang"],"content":"3. 读取多个字节 func main() { file1, err := os.OpenFile(\"./data.txt\", os.O_CREATE|os.O_RDWR, os.ModePerm) if err != nil { log.Fatal(err) } defer file1.Close() // 创建缓冲区，默认大小是4096 buf := bufio.NewReader(file1) // 指定每次读取的分割符 for { bs2, err := buf.ReadBytes('\\n') if err == io.EOF { break } fmt.Print(string(bs2)) } } ","date":"2021-06-06","objectID":"/golang_bufio_pkg/:2:3","tags":["Golang","bufio"],"title":"golang bufio包的使用","uri":"/golang_bufio_pkg/"},{"categories":["Golang"],"content":"4. 读取字符串 func main() { file1, err := os.OpenFile(\"./data.txt\", os.O_CREATE|os.O_RDWR, os.ModePerm) if err != nil { log.Fatal(err) } defer file1.Close() // 创建缓冲区，默认大小是4096 buf := bufio.NewReader(file1) for { str, err := buf.ReadString('\\n') if err != nil { break } fmt.Print(str) } } ","date":"2021-06-06","objectID":"/golang_bufio_pkg/:2:4","tags":["Golang","bufio"],"title":"golang bufio包的使用","uri":"/golang_bufio_pkg/"},{"categories":["Golang"],"content":"5. 从标准输入读取 func main() { // 读取输入 buf := bufio.NewReader(os.Stdin) for { s2, _, err := buf.ReadLine() fmt.Println(string(s2)) fmt.Println(err) if string(s2) == \"q\" { break } } } ","date":"2021-06-06","objectID":"/golang_bufio_pkg/:2:5","tags":["Golang","bufio"],"title":"golang bufio包的使用","uri":"/golang_bufio_pkg/"},{"categories":["Golang"],"content":"6. 写入数据到文件 func main() { // 写入数据 file, err := os.OpenFile(\"./data1.txt\", os.O_CREATE|os.O_RDWR, os.ModePerm) if err != nil { log.Fatal(err) } buf2 := bufio.NewWriter(file) n, err := buf2.WriteString(\"今夜特别漫长\\n\") if err != nil { log.Fatal(err) } // 将缓冲区数据刷入磁盘文件 buf2.Flush() fmt.Println(n) } ","date":"2021-06-06","objectID":"/golang_bufio_pkg/:2:6","tags":["Golang","bufio"],"title":"golang bufio包的使用","uri":"/golang_bufio_pkg/"},{"categories":["Golang"],"content":"源码解析 ","date":"2021-06-06","objectID":"/golang_bufio_pkg/:3:0","tags":["Golang","bufio"],"title":"golang bufio包的使用","uri":"/golang_bufio_pkg/"},{"categories":["Golang"],"content":"1. bufio.NewReader 用于生成一个读缓冲区。 方法的具体定义为： func NewReader(rd io.Reader) *Reader { return NewReaderSize(rd, defaultBufSize) } 传入的参数rd需要实现io.Reader接口，通过os.Open或者os.OpenFile返回的*File对象就实现了这个接口。 *Reader结构体中包含buf字段，这是一个字节切片，用做缓冲区来存放数据。 defaultBufSize用于定义buf的长度和容量，默认4096个字节。 ","date":"2021-06-06","objectID":"/golang_bufio_pkg/:3:1","tags":["Golang","bufio"],"title":"golang bufio包的使用","uri":"/golang_bufio_pkg/"},{"categories":["Golang"],"content":"2. bufio.Read 方法的声明为： func (b *Reader) Read(p []byte) (n int, err error) 当p的长度为0时，不读取数据。 当缓冲区为空，且p的长度大于等于缓冲区长度时，不经过缓冲区，直接从文件中读取数据。 当缓冲区为空，且p的长度小于缓冲区长度时，先将数据读入缓冲区，再从缓冲区读取需要的字节。 如果缓冲不为空，直接从缓冲区读取，当p读满了，或者缓冲区读空了，就返回结果。 ","date":"2021-06-06","objectID":"/golang_bufio_pkg/:3:2","tags":["Golang","bufio"],"title":"golang bufio包的使用","uri":"/golang_bufio_pkg/"},{"categories":["Golang"],"content":"3. bufio.NewWriter func NewWriter(w io.Writer) *Writer { return NewWriterSize(w, defaultBufSize) } 用于生成一个写缓冲区。逻辑类似于bufio.NewReader，返回一个*Writer结构体地址。 Writer中含有buf字段，用做缓冲区来存放数据，默认长度为4096个字节。 ","date":"2021-06-06","objectID":"/golang_bufio_pkg/:3:3","tags":["Golang","bufio"],"title":"golang bufio包的使用","uri":"/golang_bufio_pkg/"},{"categories":["Golang"],"content":"4. bufio.Write func (b *Writer) Write(p []byte) (nn int, err error) 如果写入的数据大于缓冲区可用长度，当缓冲区内无数据时，直接写入文件。 如果写入数据大于缓冲区可用长度，且缓冲区有数据，则先将数据写入缓冲区，再将缓冲区写入文件并清空缓冲区。不断重复该过程，直到剩余数据不大于缓冲区可用长度，然后仅将数据写入缓冲区，结束。 如果写入数据小于等于缓冲区可用长度，则仅仅写入缓冲区。 ","date":"2021-06-06","objectID":"/golang_bufio_pkg/:3:4","tags":["Golang","bufio"],"title":"golang bufio包的使用","uri":"/golang_bufio_pkg/"},{"categories":["Linux"],"content":"sed编辑器 sed可以根据命令来编辑数据流，大致处理流程为： 从输入读取一行数据。 按照命令对数据进行匹配。 按照命令修改匹配到的数据。 将新的数据输出到STDOUT。 读取下一行数据，并重复上述过程。 数据流读取完毕，则程序终止。 sed命令格式： sed [options] script file options可以是： -e script: 将script中的命令，添加到已有的命令列表。 -f file: 将file中指定的命令，添加到已有的命令列表。 -n：不输出每一行的处理结果。 注意： linux和mac中的sed，语法存在一定差异，本文的测试环境为linux下的bash4.2。 ","date":"2021-06-05","objectID":"/linux_sed/:1:0","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"sed options的基本使用 假设有一个data.txt文件： This is line 1. This is line 2. ","date":"2021-06-05","objectID":"/linux_sed/:2:0","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"1. 常规命令 $ sed 's/line/number/' data.txt this is number 1. this is number 2. s/line/number/是指，将line替换成number。 ","date":"2021-06-05","objectID":"/linux_sed/:2:1","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"2. 使用-e $ sed -e 's/line/number/' -e 's/this/This/' data.txt This is number 1. This is number 2. ","date":"2021-06-05","objectID":"/linux_sed/:2:2","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"3. 使用-f $ cat script.sed s/line/number/ s/this/This/ $ ed -f script.sed data.txt This is number 1. This is number 2. ","date":"2021-06-05","objectID":"/linux_sed/:2:3","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"sed script的基本语法 ","date":"2021-06-05","objectID":"/linux_sed/:3:0","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"1. 替换s 可以使用s命令来替换文本，还可以指定替换标记： s/pattern/replacement/[flags] 替换标记是可选的，具体有以下几种： 数字：表明替换第几处匹配的地方。 $ cat data.txt this is line 1. this is line 2. $ sed 's/is/was/2' data.txt this was line 1. this was line 2. g：替换所有匹配的文本。 $ cat data.txt this is line 1. this is line 2. $ sed 's/is/*/g' data.txt th* * line 1. th* * line 2. p：输出被修改过的行。 $ cat data.txt this is line 1. this is line 2. $ sed 's/line 1/*/p' data.txt this is *. this is *. this is line 2. $ sed -n 's/line 1/*/p' data.txt this is *. w file：将替换的结果输出到file。 $ cat data.txt this is line 1. this is line 2. $ sed 's/line 1/*/w result.txt' data.txt this is *. this is line 2. $ cat result.txt this is *. 替换命令的分隔符/可以换成其他自定义字符： $ cat data.txt this is line 1. this is line 2. $ sed 's,line,number,' data.txt this is number 1. this is number 2. ","date":"2021-06-05","objectID":"/linux_sed/:3:1","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"2. 行寻址 sed默认作用于所有行，如果想指定行号，命令格式为： [address]command 寻址方式有两种： 数字方式。 指定单个行号： $ sed '2s/line/number/' data.txt this is line 1. this is number 2. 指定地址区间： $ sed '1,2s/line/number/' data.txt this is number 1. this is number 2. $表示最后一行： $ sed '1,$s/line/number/' data.txt this is number 1. this is number 2. 文本模式。 $ sed '/line 2/s/line/*/' data.txt this is line 1. this is * 2. 文本模式可以使用正则表达式，具体正则表达式的用法不做说明。 ","date":"2021-06-05","objectID":"/linux_sed/:3:2","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"3. 命令组合 如果想执行多条命令，可以使用分号分隔。 $ sed '1s/line/number/; 1s/is/*/' data.txt th* is number 1. this is line 2. 可以将命令写成多行。 $ sed ' \u003e 1,$s/line/number/ \u003e 1,$s/is/*/ \u003e ' data.txt th* is number 1. th* is number 2. 也可以使用花括号{}将多条命令组合在一起。 $ sed '1,${s/line/number/ ; s/is/*/}' data.txt th* is number 1. th* is number 2. ","date":"2021-06-05","objectID":"/linux_sed/:3:3","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"4. 删除d 可以使用删除命令d删除指定行，删除时也可以使用行寻址。 $ sed '1d' data.txt this is line 2. 使用区间寻址时，第一个匹配模式是打开删除功能，第二个模式是关闭删除功能。 ","date":"2021-06-05","objectID":"/linux_sed/:3:4","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"5. 插入i 插入命令i会在指定行前增加一个新行。 sed '[address]i\\ new line' 如果省略address，则是在每行前增加新行。 ","date":"2021-06-05","objectID":"/linux_sed/:3:5","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"6. 追加a 追加命令a会在指定行后增加一个新行。 sed '[address]a\\ new line' 如果省略address，则是在每行后增加新行。 ","date":"2021-06-05","objectID":"/linux_sed/:3:6","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"7. 修改c 修改命令c可以修改整行的数据内容。 $ sed '2c\\ \u003e this is new line 2' data.txt this is line 1. this is new line 2 如果使用区间寻址，c会对整个区间做替换。 如果省略寻址，则对每行数据做修改。 ","date":"2021-06-05","objectID":"/linux_sed/:3:7","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"8. 转换y 转换命令y可以对单个字符做一对一映射转换。 [address]y/chars1/chars2/ chars1和chars2的长度必须一致，chars1中的字符，会被转换为char2中的字符。 $ sed 'y/hijk/HIJK/' data.txt tHIs Is lIne 1. tHIs Is lIne 2. y是一个全局命令。 ","date":"2021-06-05","objectID":"/linux_sed/:3:8","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"9. 打印命令p 打印命令p和替换标记p类似，可以打印匹配到的数据行。 $ sed -n '1p' data.txt this is line 1. ","date":"2021-06-05","objectID":"/linux_sed/:3:9","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"10. 打印行号 命令=可以打印被匹配数据在文本中的行号。 $ sed '/2/=' data.txt this is line 1. 2 this is line 2. ","date":"2021-06-05","objectID":"/linux_sed/:3:10","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"11. 列出l 列出命令l可以打印匹配数据，包括文本字符和不可打印的转义字符。 ","date":"2021-06-05","objectID":"/linux_sed/:3:11","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"12. 写入命令 w命令可以将匹配数据写入文件。 [address]w filename ","date":"2021-06-05","objectID":"/linux_sed/:3:12","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"13. 读取数据 读取命令r从文件中读取数据，并插入到匹配行后面。 [address]r filename ","date":"2021-06-05","objectID":"/linux_sed/:3:13","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"sed script进阶语法 假设数据文件data.txt为： this is line 1. this is line 2. this is line 3. this is line 4. this is line 5. ","date":"2021-06-05","objectID":"/linux_sed/:4:0","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"1. 模式空间和保持空间 sed在执行命令时，会保存待检查的文本。保存文本，需要用到两个缓冲区，模式空间和保持空间。 执行命令时，读到的数据会保存在模式空间，保持空间主要是起辅助作用。 与缓冲区有关的命令： h: 将模式空间复制到保持空间 H: 将模式空间附加到保持空间 g: 将保持空间复制到模式空间 G: 将保持空间附加到模式空间 x: 交换模式空间和保持空间的内容 ","date":"2021-06-05","objectID":"/linux_sed/:4:1","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"2. 单行数据的next命令 单行next命令会将匹配数据的下一行，移到sed的模式空间，移动前会清空模式空间。 $ sed -n '/line 4/{n; p}' data.txt this is line 5. ","date":"2021-06-05","objectID":"/linux_sed/:4:2","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"3. 多行数据的next命令 多行next命令，会以追加的方式，将匹配行的下一行添加到模式空间。并且，sed会将模式空间中的数据当成一行处理。 $ sed -n '/line 3/{N; p}' data.txt this is line 3. this is line 4. 当要匹配的数据在多行中时，这种语法就能很好的发挥作用。 ","date":"2021-06-05","objectID":"/linux_sed/:4:3","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"4. 多行删除命令D 多行删除命令D，会删除模式空间中的第一行。 注意，d会删除模式空间中的所有数据。 ","date":"2021-06-05","objectID":"/linux_sed/:4:4","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"5. 多行打印命令P 多行打印命令P，会打印模式空间中的第一行。 注意，p会打印模式空间中的所有数据。 ","date":"2021-06-05","objectID":"/linux_sed/:4:5","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"6. 排除命令 排除命令!用于将后续命令作用于非匹配行。 $ sed -n '1,2!p' data.txt this is line 3. this is line 4. this is line 5. ","date":"2021-06-05","objectID":"/linux_sed/:4:6","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"7. 分支命令 分支命令b可以用来改变命令的执行流程。 [address]b [label] address用于寻址，label制定了跳转位置，如果省略label，则跳转到命令脚本的结尾。 $ sed '3b ; s/this is line/*/' data.txt * 1. * 2. this is line 3. * 4. * 5. sed ' \u003e 3b start \u003e s/this is line/*/ \u003e :start \u003e s/this is line/jump/ \u003e ' data.txt * 1. * 2. jump 3. * 4. * 5. ","date":"2021-06-05","objectID":"/linux_sed/:4:7","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"8. 测试命令 测试命令t会根据替换命令的结果，来决定是否跳转到某个标签。 如果没有指定标签，则跳转到命令结尾。 sed ' \u003e s/line 3/*/ \u003e t \u003e s/this is line/*/ \u003e ' data.txt * 1. * 2. this is *. * 4. * 5. ","date":"2021-06-05","objectID":"/linux_sed/:4:8","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"9. 匹配模式 \u0026符号代表替换命令中与模式匹配的文本。 $ echo \"The cat sleeps in his hat.\" | sed 's/.at/\"\u0026\"/g' The \"cat\" sleeps in his \"hat\". 也可以提取替换模式的字模式。 $ echo \"That furry cat is pretty\" | sed 's/furry \\(.at\\)/\\1/' That cat is pretty ","date":"2021-06-05","objectID":"/linux_sed/:4:9","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"sed 示例 ","date":"2021-06-05","objectID":"/linux_sed/:5:0","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"1. 反序输出文本 $ cat data.txt this is line 1. this is line 2. this is line 3. this is line 4. this is line 5. # tac命令可以反序输出 $ tac data.txt this is line 5. this is line 4. this is line 3. this is line 2. this is line 1. # sed也可以反序输出 $ sed -n '1!G; h; $p' data.txt this is line 5. this is line 4. this is line 3. this is line 2. this is line 1. ","date":"2021-06-05","objectID":"/linux_sed/:5:1","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"2. 加倍行距 $ cat data.txt this is line 1. this is line 2. this is line 3. this is line 4. this is line 5. $ sed '/^$/d;$!G' data.txt this is line 1. this is line 2. this is line 3. this is line 4. this is line 5. ","date":"2021-06-05","objectID":"/linux_sed/:5:2","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"3. 给文件的行编号 $ nl data.txt 1 this is line 1. 2 this is line 2. 3 this is line 3. 4 this is line 4. 5 this is line 5. $ cat -n data.txt 1 this is line 1. 2 this is line 2. 3 this is line 3. 4 5 this is line 4. 6 this is line 5. $ sed '=' data.txt | sed 'N; s/\\n/ /' 1 this is line 1. 2 this is line 2. 3 this is line 3. 4 5 this is line 4. 6 this is line 5. ","date":"2021-06-05","objectID":"/linux_sed/:5:3","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"4. 打印末尾行 # 打印最后10行 $ sed ':start; N; 11,$D; b start' data.txt this is line 5. this is line 6. this is line 7. this is line 8. this is line 9. this is line 10. this is line 11. this is line 12. this is line 13. this is line 14. ","date":"2021-06-05","objectID":"/linux_sed/:5:4","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"5. 删除文本中的连续空白行 $ cat data.txt this is line 1. this is line 2. this is line 3. this is line 4. this is line 5. $ sed '/./,/^$/!d' data.txt this is line 1. this is line 2. this is line 3. this is line 4. this is line 5. ","date":"2021-06-05","objectID":"/linux_sed/:5:5","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"6. 删除开头空白行 $ cat data.txt this is line 1. this is line 2. this is line 3. this is line 4. this is line 5. $ sed '/./,$!d' data.txt this is line 1. this is line 2. this is line 3. this is line 4. this is line 5. ","date":"2021-06-05","objectID":"/linux_sed/:5:6","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"7. 删除结尾空白行 $ cat data.txt this is line 1. this is line 2. this is line 3. this is line 4. this is line 5. $ sed ':start; /^\\n*$/{$d; N; b start}' data.txt this is line 1. this is line 2. this is line 3. this is line 4. this is line 5. ","date":"2021-06-05","objectID":"/linux_sed/:5:7","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"}]