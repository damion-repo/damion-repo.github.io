[{"categories":["MySQL"],"content":"概念 DB 数据库（database)：存储数据的仓库。它保存了一系列有组织的数据。 DBMS 数据库管理系统（database management system）。数据库是通过DBMS创建和操作的容器。 SQL 结构化查询语言（structure query language）:专门用来与数据库通信的语言。 ","date":"2021-06-18","objectID":"/mysql_grammer/:1:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"存储数据的特点 一个数据库可以有多个表，每个表有一个名字。表名具有唯一性。 表具有一些特性，这些特性定义了数据在表中如何存储。 表由列组成，列也称为字段。 表中的数据是按行存储的。 ","date":"2021-06-18","objectID":"/mysql_grammer/:2:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"SQL分类 DDL: 数据定义语言，用来定义数据库对象（库、表、列等）。 DML: 数据操作语言，用来定义数据库记录（增、删、改）。 DCL: 数据控制语言，用来定义访问权限和安全级别。 DQL: 数据查询语言，用来查询记录。 ","date":"2021-06-18","objectID":"/mysql_grammer/:3:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"rpm安装mysql rpm -ivh rpm软件名 ","date":"2021-06-18","objectID":"/mysql_grammer/:4:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"Mysql核心目录 1. 分类 /var/lib/mysql：安装目录 /usr/share/mysql：配置文件 /usr/bin：命令目录（mysqladmin、mysqldump等） /etc/init.d/mysql：启动脚本 2. 配置文件 my-huge.cnf：高端服务器 my-large.cnf：中等规模 my-medium.cnf：一般 my-small.cnf：较小 以上配置文件默认不能识别，mysql5.5默认只能识别 /etc/my.cnf，mysql5.6默认识别 /etc/mysql-default.cnf。 ","date":"2021-06-18","objectID":"/mysql_grammer/:5:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"mysql字符编码 1. 查看语法 showvariableslike'%char%'; 2. 设置编码 修改/etc/my.cnf [mysql] default-character-set=utf8 [client] default-character-set=utf8 [mysqld] character_set_server=utf8 character_set_client=utf8 collation_server=utf8_general_co 修改编码，只对之后创建的数据库生效。 ","date":"2021-06-18","objectID":"/mysql_grammer/:6:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"查看表的结构 1. 语法 DESCname; 或者： SHOWCOLUMNSFROMtablename; 或者： SHOWCREATETABLEtablename; ","date":"2021-06-18","objectID":"/mysql_grammer/:7:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"查询语句 1. 语法 select查询列表from表名; 2. 执行顺序： from子句 select子句 3. 查询列表： 字段 SELECT`last_name`FROM`employees` 表达式 SELECT100%3; 常量 SELECT100; 函数等 SELECTDATABASE();SELECTVERSION();SELECTUSER(); 4. 起别名 使用as关键字 SELECTUSER()as\"username\"; 使用空格 selectuser()username; 5. mysql中+的作用 如果两个数都是数值型，则直接相加。 如果其中一个操作数为字符型，则将字符型转换成数值型。如果无法转换，则直接当作0处理。 其中一个操作数为null，结果为null。 6. distinct函数 SELECTDISTINCTfieldFROMtablename 7. ifnull函数 语法： ifnull(表达式1,表达式2) 功能： 如果表达式1为null，则显示表达式2，否则显示表达式1。 ","date":"2021-06-18","objectID":"/mysql_grammer/:8:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"条件查询 1. 语法 select查询列表from表名where筛选条件； 2. 执行顺序 from子句。 where子句。 select子句。 3. 筛选条件 按关系表达式筛选：\u003c、\u003e、\u003e=、\u003c=、=、\u003c\u003e，也可以使用 != 但是不建议，ANSI标准中用的是\u003c\u003e。 按逻辑表达式筛选：and、or、not，也可以使用 \u0026\u0026、||、! 但是不建议。 模糊查询：like、in、between ... and ...、is null。 4. 示例 查询部门编号不是 50 ~ 100 之间员工的姓名: selectnamefromemployeeswheredepartment_id\u003c50ordepartment_id\u003e100; 查询姓名中包含字符a的员工。 select*fromemployeeswherenamelike'%a%'; 查询姓名最后一个字符为a的员工。 select*fromemployeeswherenamelike'%a'; 查询姓名第一个字符为a的员工。 select*fromemployeeswherenamelike'a%'; 查询姓名中第三个字符为a的员工。 select*fromemployeeswherenamelike'___a%';# 有三个下划线_ 查询姓名中第二个字符为_的员工信息。 select*fromemployeeswherenamelike'_\\_%';# 或者 # select * from employees where name like '_$_%' escape '$'; 查询部门编号是30/50/90的员工名 selectnamefromemployeeswheredepartmentin(30,50,90); 查询部门编号是30～90之间的员工姓名 selectnamefromemployeeswheredepartmentbetween30and90; 查询部门编号不是30～90之间的员工姓名 selectnamefromemployeeswheredepartmentnotbetween30and90; ","date":"2021-06-18","objectID":"/mysql_grammer/:9:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"排序查询 1. 语法 select查询列表from表名where筛选条件orderby排序列表 2. 执行顺序 from子句 where子句 select子句 order by子句 3. 说明 排序列表可以是单个字段、多个字段、表达式、函数、列数、以及以上的组合。 默认升序asc，降序desc 4. 示例 将员工按照工资降序 select*fromemployeesorderbysalarydesc; 按姓名长度进行升序 selectnamefromemployeesorderbylength(name); 查询员工信息，先按工资升序、再按部门将序 select*fromemployeesorderbysalaryasc,departmentdesc; 按照列数进行排序 select*fromemployeesorderby2desc; ","date":"2021-06-18","objectID":"/mysql_grammer/:10:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"常见函数 1. 分类 字符函数 数学函数 日期函数 流程控制函数 2. 字符函数 concat拼接字符 selectconcat(\"hello\",name)fromuser; LENGTH获取字节长度 selectlength(\"hello,少年\"); CHAR_LENGTH获取字符长度 SELECTCHAR_LENGTH(\"hello,少年\"); SUBSTR截取子串 SELECTSUBSTR('少年你好骚啊',1,2);# SELECT SUBSTR('你好骚啊少年',5); INSTR获取字符第一次出现的索引 SELECTINSTR('孙悟空三打白骨精','白骨精'); TRIM去除前后指定字符，默认去空格 SELECTTRIM(' 空 格 ')asresult; SELECTTRIM('x'FROM'xxx空xxx格xxx')asresult; LPAD/RPAD左填充/右填充 # 左填充满10个字符 SELECTLPAD('木婉清',10,'a');# 右填充满10个字符 SELECTRPAD('木婉清',10,'a'); UPPER/LOWER变大写/变小写 STRCMP比较两个字符大小 SELECTSTRCMP('abc','acb') LEFT/RIGHT截取子串 SELECTLEFT('洪世贤',1); 3. 数学函数 ABS绝对值 SELECTABS(-1.1); CELL向上取整，返回大于等于该参数的最小整数 SELECTCELL(1.09); FLOOR向下取整，返回小于等于该参数的最大整数 SELECTFLOOR(-1.09); ROUND四舍五入 SELECTROUND(1.8765); TRUNCATE截断 SELECTTRUNCATE(1.8765,1);# 位数不够用0补齐 MOD取余，实质上 a % b = a - a/b*b。 SELECTMOD(-10,3);# SELECT -10%3; # SELECT 10%3; # SELECT -10%-3; # SELECT 10%-3; 4. 日期函数 NOW SELECTNOW(); CURDATE SELECTCURDATE(); CURTIME SELECTCURTIME(); DATEDIFF SELECTDATEDIFF('1998-7-16','2019-7-13'); DATE_FORMAT SELECTDATE_FORMAT('1998-7-16','%Y年%M月%d日 %H小时%i分钟%s秒'); STR_TO_DATE SELECTSTR_TO_DATE('3/15 1998','%m/%d %Y'); 5. 流程控制函数 IF函数 SELECTIF(100\u003e9,\"好\",\"坏\"); CASE函数 CASE表达式WHEN值1THEN结果1WHEN值2THEN结果2...ELSE结果nEND 或者 CASEWHEN条件1THEN结果1WHEN条件2THEN结果2...ELSE结果NEND ","date":"2021-06-18","objectID":"/mysql_grammer/:11:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"分组函数 1. 说明 往往用于实现将一组数据进行统计计算，最终得到一个值，又称为聚合函数或者统计函数。 2. 列表 sum(字段名): 求和 avg(字段名): 求平均数 max(字段名): 求最大值 min(字段名): 求最小值 count(字段名): 计算非空字段值的个数 3. 补充说明 count(*)用于查询总行数。 count(1)作用类似于count(*)，但是效率较低。 count()搭配distinct做去重统计，如 selectcount(distinctdepartment)fromemployees; 4. 示例 查询员工信息表中，所有员工的工资和、平均工资值、最低工资、最高工资、有工资的个数。 selectsum(salary),avg(salary),min(salary),max(salary),count(salary)fromemployees; ","date":"2021-06-18","objectID":"/mysql_grammer/:12:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"分组查询 需要使用group by子句。 1. 语法 select查询列表from表名where筛选条件groupby分组列表having分组后筛选orderby排序列表; 2. 执行顺序 from子句 where子句 group by子句 having子句 select子句 order by子句 3. 说明 查询列表往往是分组函数和被分组的字段。 分组前筛选，基于原始表，使用where，位于group by前面。 分组后筛选，基于分组后的结果集，使用having，位于group by后面。 4. 示例 查询每个工种员工平均工资 selectavg(salary),job_idfromemployeesgroupbyjob_id; ","date":"2021-06-18","objectID":"/mysql_grammer/:13:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"连接查询 1. 说明 又成多表查询，当查询的字段来自于多个表时，就会用到连接查询。 2. sql连接查询分类 年代： sql92标准：mysql仅仅支持内连接 sql99标准：mysql支持内连接+外连接（左外和右外）+交叉连接 功能： 内连接：等值连接、非等值连接、自连接 外连接：左外连接、右外连接、全外连接 交叉连接 ","date":"2021-06-18","objectID":"/mysql_grammer/:14:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"sql92内连接 1. 语法 select查询列表from表名1别名1,表名2别名2...where连接条件 2. 说明 为了解决多表字段重名，可以为表起别名。 表的顺序无要求。 n表连接，至少需要n-1个连接条件。 3. 示例 等值连接：查询部门编号\u003e100的部门名和所在的城市名。 SELECT`department_name`,`city`FROMdepartmentsd,locationslWHEREd.`location_id`=l.`location_id`ANDd.`department_id`\u003e100; 非等值连接：查询员工的工资和工资级别。 SELECTsalary,grade_levelFROMemployeese,job_gradesgWHEREsalaryBETWEENg.`lowest_sal`ANDg.`highest_sal`; 自连接：查询员工名和上级的名称。 SELECTe.employee_id,e.last_name,m.employee_id,m.last_nameFROMemployeese,employeesmWHEREe.`manager_id`=m.`employee_id`; ","date":"2021-06-18","objectID":"/mysql_grammer/:15:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"sql99内连接 1. 语法 SELECT查询列表FROM表明1别名[INNER]JOIN表明2别名ON连接条件WHERE筛选条件GROUPBY分组列表HAVING分组后筛选ORDERBY排序列表; 2. 说明 使用关键字JOIN代替了逗号，连接条件和筛选条件进行了分离。 3. 示例 查询员工名和部门名 SELECTlast_name,department_nameFROMemployeeseJOINdepartmentsdONe.department_id=d.department_id; 查询部门编号\u003e100的部门名和所在的城市名 SELECTdepartment_name,cityFROMdepartmentsdJOINlocationslONd.`location_id`=l.`location_id`WHEREd.`department_id`\u003e100; 查询部门中员工个数\u003c10的部门名，并按照员工个数降序 SELECTCOUNT(*)员工个数,d.department_nameFROMemployeeseJOINdepartmentsdONe.`department_id`=d.`department_id`GROUPBYd.`department_id`HAVING员工个数\u003e10ORDERBY员工个数DESC; 查询部门员工的工资级别，并按照级别进行分组 SELECTCOUNT(*)个数,g.gradeFROMemployeeseJOINsal_gragegONe.`salary`BETWEENg.`min_salary`ANDg.`max_salary`GROUPBYg.grade 查询员工名和对应的领导名 SELECTe.`name`,m.`name`FROMemployeeseJOINemployeesmONe.`manager_id`=m.`employee_id` ","date":"2021-06-18","objectID":"/mysql_grammer/:16:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"SQL99外连接 1. 说明 查询结果为主表中所有的记录，如果从表有匹配项，则显示匹配项；如果从表没有匹配项，则显示null。 一般用于查询主表中有但从表中没有的记录。 外连接主从表的顺序不可随意改变。 左连接的主表在左边。 右连接的主表在右边。 2. 语法 select查询列表from表1别名left|right|full[outer]join表2别名on连接条件where筛选条件; ","date":"2021-06-18","objectID":"/mysql_grammer/:17:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"子查询 1. 定义 当一个查询语句中，又嵌套了另一个完整的select语句，则被嵌套的语句称为子查询或内查询。 外面的语句称为主查询或外查询。 2. 说明 子查询不一定必须出现在select子句中，只是这种情况比较常见。 子查询放在条件中，要求必须出现在条件右侧 子查询一般放在小括号中 单行子查询对应了单行操作符：\u003e, \u003c, \u003e=, \u003c=, =, \u003c\u003e 多行子查询对应了多行操作符：any, some, all, in（some和any的用法一致） 3. 分类 按出现位置： select后面：子查询结果必须单行单列（标量子查询） from后面：子查询结果可以多行多列 where或者having后面：子查询的结果必须为单列 4. 示例 查询和Tom同部门的员工姓名和工资 SELECTname,salaryFROMemployeesWHEREdepartment_id=(SELECTdepartment_idFROMemployeesWHEREname='Tome'); 查询部门编号是50的员工个数 SELECT(SELECTCOUNT(*)FROMemployeesWHEREdepartment_id=50)个数; 查询有无名字叫\"TOM\"的员工信息 SELECTEXISTS(SELECT*FROMemployeesWHEREname=\"TOM\")有无; ","date":"2021-06-18","objectID":"/mysql_grammer/:18:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"sql99交叉连接 1. 语法 select查询列表from表1别名1crossjoin表2别名2where筛选条件; 或者 select查询列表from表1别名,表2别名,...where筛选条件; ","date":"2021-06-18","objectID":"/mysql_grammer/:19:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"分页查询 1. 语法 select查询列表from表1别名join表2别名on连接条件where筛选条件groupby分组having分组后筛选orderby排序列表limit起始条目索引，条目数 2. 执行顺序 from -\u003e on -\u003e join -\u003e where -\u003e group by -\u003e having -\u003e select -\u003e order by -\u003e limit 3. 说明 起始条目索引从0开始，缺省则默认为0 4. 示例 查询员工信息表的前5条 SEELCT*FROMemployeesLIMIT5;# 等价于 # SELECT * FROM employees LIMIT 0,5; ","date":"2021-06-18","objectID":"/mysql_grammer/:20:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"联合查询 1. 说明 当查询结果来自于多张表，但多张表之间没有关联，这时可用联合查询，也称union查询。 union自动去重 union all可以支持重复项 多条待联合的查询语句，查询列数必须一致，类型、字段最好一致 2. 语法 select查询列表from表1where筛选条件unionselect查询列表from表2where筛选条件 3. 示例 查询所有国家的年龄\u003e20的用户信息 SELECT*FROMchineseWHEREage\u003e20UNIONSELECT*FROMusaWHEREuage\u003e20; 查询所有国家的用户姓名和年龄 SELECTuname,uageFROMusaUNIONSELECTage,`name`FROMchinese; ","date":"2021-06-18","objectID":"/mysql_grammer/:21:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"DDL语言 1. 说明 DDL: （Data Define Language）数据定义语言，用于对数据库和表的管理和操作。 2. 库管理 创建数据库 CREATEDATABASE库名;# CREATE DATEBASE IF NOT EXISTS 库名; # 如果不存在则创建 删除数据库 DROPDATABASE库名;# DROP DATABASE IF EXISTS 库名; # 如果存在则删除 3. 表管理 创建表 语法： CREATETABLE[IFNOTEXISTS]表名(字段名字段类型[字段约束]，......字段名字段类型[字段约束],字段名字段类型[字段约束]); 示例： CREATETABLEstuinfo(stuidINT,stunameVARCHAR(20),stugenderCHAR,emailVARCHAR(20),ageINT,majoridINT,CONSTRAINTfk_stuinfo_majorFOREIGNKEY(majorid)REFERENCESmajor(id)); 修改表 修改表名： ALTERTABLE原表名RENAMETO新表名; 修改表字段： ALTERTABLE表名ADD|MODIFY|CHANGE|DROPCOLUMN字段名字段类型字段约束; 示例： ALTERTABLEstuinfoRENAMETOstudents; ALTERTABLEstudentsADDCOLUMNdorndateTIMESTAMPNOTNULL; ALTERTABLEstudentsCHANGECOLUMNborndatebirthdayDATETIMENULL; ALTERTABLEstudentsMODIFYCOLUMNbirthdayTIMESTAMP; ALTERTABLEstudentsDROPCOLUMNbirthday; 删除表 DROPTABLEIFEXISTStablename; 复制表 CREATETABLEtablename1LIKEtablename2;# 仅复制表结构 CREATETABLEtablename1SELECT*FROMtablename2;# 复制结构和数据 示例： CREATETABLEempSELECTnameFROMemployeesWHERE1=2; ","date":"2021-06-18","objectID":"/mysql_grammer/:22:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"常用字段类型 1. int 整形：TYNYINT, SMALLINT, INT, BIGINT。 2. double/float 浮点型，例如double(5, 2)表示最多5位，其中有且仅有2位小数，即最大值为999.99 3. decimal 浮点型，表示钱时使用该类型，不会出现精度问题 4. char 固定长度字符串类型；内容范围是0~255字节； char(n)：n参数默认为1，不管实际存储，开辟空间都是n个字符，效率高。 5. varchar 可变长度字符串类型；内容范围为0~65535字节； varchar(n)最大字符个数必选，根据实际存储空间决定开辟空间，效率低。 实际占用空间为：字符实际空间 + 1，且字符实际空间 + 1 \u003c= n。 6. text 字符串类型，通常存储较长文本。 7. blob 字节类型；常用于jpg, mp3, avi。 8. date 日期类型；格式为yyyy-MM-dd 9. time 时间类型；格式为hh:mm:ss 10. timestamp/datetime 时间戳类型；格式为yyyyMMdd hhmmss； timestamp保存范围1900-1-1~xxxx年，占用8字节； datetime保存范围1970-1-1~2038-12-31，占用4字节。 ","date":"2021-06-18","objectID":"/mysql_grammer/:23:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"常见字段约束 1. 说明 用于限制表中字段的数据； 2. 列表 NOT NULL 非空；用于限制该字段为必填项； DEFAULT 默认；如果该字段没有插入值，则显示默认值； PRIMARY KEY 主键；用于限制该字段的值不能重复；设为主键列的字段默认不能为空； ALTERTABLEtbl_nameADDPRIMARYKEY(column_list); UNIQUE 唯一；限制该字段不能重复；该字段可以为空； CHECK 检查；限制该字段值必须满足指定条件；mysql不支持； FOREIGN KEY 外键；限制两个表的关系；外键列的值必须来自主表的关联列；主表关联列和从表关联列类型必须一致，意思一样，名称无要求；主表的关联列要求必须是主键； 定义外键： altertableteblenameaddconstraint外键名foreignkey(列名)references表名（关联列）; 或者： createtableteblename(...constraint外键名foreignkey(列名)references表名(关联列)); 删除外键： altertabletablenamedropforeignkey键名 ","date":"2021-06-18","objectID":"/mysql_grammer/:24:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"设置自增长列 1. 关键字 AUTO_INCREMENT 2. 说明 自增长列必须设置在一个键上，比如主键或唯一键。 自增长列要求数据类型为数值型。 一个表至多有一个自增长列。 ","date":"2021-06-18","objectID":"/mysql_grammer/:25:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"DML DML: (Data Manipulation Language) 数据操作语言 插入数据 修改数据 删除数据 ","date":"2021-06-18","objectID":"/mysql_grammer/:26:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"插入数据 1. 语法 插入单行 insertinto表名(字段名1，字段名2，......)values(值1，值2，......); 插入多行 insertinto表名（字段名1，字段名2，......)values(值1，值2，......),(值1，值2，......)...; 2. 说明 字段和值列表一一对应。 数值型值不用单引号，非数值型值必须使用单引号。 3. 示例 INSERTINTOstuinfo(stuid,stuname,stugender,email,age,majorid)VALUES(1,'TOm','男','tom@gmail.com',12,1); ","date":"2021-06-18","objectID":"/mysql_grammer/:27:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"修改数据 1. 语法 修改单表： update表名set列=新值,列=新值,...where筛选条件; 修改多表，sql92语法： update表名1别名，表名2别名set列=值,...where连接条件and筛选条件; 修改多表，sql99语法： update表1别名inner|left|rightjoin表2别名on连接条件set列=值,...where筛选条件; ","date":"2021-06-18","objectID":"/mysql_grammer/:28:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"删除数据 1. 语法 delete语句： deletefrom表名where筛选条件; truncate语句: truncatetable表名; 2. delete和truncate的区别： delete可以添加where条件，truncate不能添加where条件，一次性清除所有数据。 truncate的效率较高。 如果删除带自增长列的表；使用delete删除后，重新插入数据时，记录从断点处开始；使用truncate删除后，重新插入数据时，记录从1开始。 delete删除数据时，会返回受影响的行数；truncate删除数据时，不会返回受影响的行数。 delete删除数据时，可以支持事务回滚；truncate删除数据时，不支持事务回滚。 ","date":"2021-06-18","objectID":"/mysql_grammer/:29:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"事务 1. 概念： 一个事务是由一条或者多条sql语句构成，这一条或者多条sql语句，要么全部执行成功，要么全部执行失败。 2. 四大特性： 原子性 (atomicity)：事务中所有操作是不可再分割的原子单位。事务中所有操作要么全部执行成功，要么全部执行失败。 一致性 (consistency)：事务执行后，数据库状态与业务规则保持一致。如转账业务，无论事务执行成功与否，参与转账的两个账号余额之和应该是不变的。 隔离性 (isolation)：在并发操作中，不同事务之间应该隔离开来，使每个并发中的事务不会相互干扰。 持久性 (durability)：一旦事务提交成功，事务中所有的数据操作都必须被持久化到数据库。即使提交事务后，数据库马上崩溃，在数据库重启时，也能通过某种机制恢复数据。 3. 分类 隐式事务：没有明显的开启和结束标记 显式事务：具有明显的开启和结束标记 步骤：取消隐式事务自动开启的功能 =\u003e 开启事务 =\u003e 编写事务语句 =\u003e 结束事务 4. 示例 #取消事务自动开启 SETautocommit=0;#开启事务 有的客户端不用加这句 STARTTRANSACTION;#更新数据 UPDATEstuinfoSETbalance=balance-5000wherestuid=1;UPDATEstuinfoSETbalance=balabce+5000wherestuid=2;#提交 COMMIT;#或者回滚 #ROLLBACK; ","date":"2021-06-18","objectID":"/mysql_grammer/:30:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"数据库的隔离级别 1. 说明 对于同时运行的多个事务，当这些事务访问数据库中相同的数据时，如果没有采取必要的隔离机制，就会导致各种并发问题： 脏读：对于两个事务T1和T2，T1读取了已经被T2更新但还没有被提交的字段，若之后T2回滚，T1读取的内容就是临时且无效的。 不可重复读：对于两个事务T1和T2，T1读取了一个字段，然后T2更新了该字段，之后T1再次读取同一个字段，获得的值就不同了。 幻读：对于两个事务T1和T2，T1从一个表中根据某些条件读取出一些记录，然后T2向该表插入了符合条件的新纪录，T1再次读取时，就会把新纪录也读出来。 一个事务与其他事务隔离的程度称为隔离级别。不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性就越好，但并发性越弱。 ","date":"2021-06-18","objectID":"/mysql_grammer/:31:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"数据的4种隔离级别 1. 隔离级别说明 读未提交数据(READ UNCOMMITTED)：允许事务读取未被其他事务提交的变更。脏读，不可重复读和幻读的问题都会出现。 读已提交数据(READ COMMITTED)：只允许事务读取已经被其他事务提交的变更。可以避免脏读，但不可重复读和幻读问题仍然会出现。 可重复读(REPEATABLE READ)：确保事务可以多次从一个字段中读取相同的值，但这个事务持续期间，禁止其他事务对这个字段进行更新。可以避免脏读和不可重复读，但幻读的问题仍然存在。 串行化(SERIALIZABLE)：确保事务可以从一个表中读取相同的行，在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作，所有并发问题都可以避免，但性能十分低下。 2. Oracle支持的事务隔离级别： READ COMMITED（默认） SERIALIZABLE 3. Mysql支持的事务隔离级别 READ UNCOMMITTED READ COMMITTED REPEATABLE READ（默认） SERIALIZABLE ","date":"2021-06-18","objectID":"/mysql_grammer/:32:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"MySql设置隔离级别 1. 说明 每启动一个mysql客户端程序，就会获得一个单独的连接，每个连接都有一个变量@@tx_isolation表示当前的事务隔离级别。 2. mysql查看当前连接的隔离级别 select@@tx_isolation; 3. mysql修改当前连接的隔离级别 当前连接的隔离级别不会影响到其他连接。 setsessiontransactionisolationlevelreaduncommitted; 4. mysql设置数据库系统全局的隔离级别 需要重新打开mysql会话，设置才会生效。 setglobaltransactionisolationlevelreadcommitted; ","date":"2021-06-18","objectID":"/mysql_grammer/:33:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"SAVEPOINT 1. 说明 只能搭配rollback使用 2. 示例 SETautocommit=0;DELETEFROMaccountWHEREid=25;SAVEPOINTa;DELETEFROMaccountWHEREid=28;ROLLBACKTOa; ","date":"2021-06-18","objectID":"/mysql_grammer/:34:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"视图 1. 含义 虚拟表，和普通表一样使用。 mysql5.1版本之后出现的新特性。 行和列的数据，来自定义视图时的查询中使用到的表，并且是在使用视图时动态生成的。 只保存了sql逻辑，不保存查询结果。 2. 应用场景 多个地方用到同样的查询结果。 该查询结果使用的sql语句较复杂。 ","date":"2021-06-18","objectID":"/mysql_grammer/:35:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"创建视图 1. 语法 createview视图名as查询语句; 2. 示例 查询邮箱中包含a字符的员工名、部门名和工种信息。 #创建视图 CREATEVIEWmyv1ASSELECTname,department,titleFROMemployeeseJOINdepartmentsdONe.department_id=d.department_idJOINjobsjONj.job_id=e.job_id;#使用视图 SELECT*FROMmyv1WHEREnameLIKE\"%a%\"; 查询各部门的平均工资级别 #创建视图 CREATEVIEWmyv2ASSELECTAVG(salary)ag,department_idFROMemployeesGROUPBYdepartment_id;#使用 SELECTmyv2.`ag`,g.grade_levelFROMmyv2JOINjob_gradesgONmyv2.`ag`BETWEENg.`lowest_sal`ANDg.`highest_sal`; ","date":"2021-06-18","objectID":"/mysql_grammer/:36:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"修改视图 1. 语法 方式一： createorreplaceview视图名as查询语句; 方式二： alterview视图名as查询语句; ","date":"2021-06-18","objectID":"/mysql_grammer/:37:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"删除视图 1. 语法 dropview视图名，视图名......; ","date":"2021-06-18","objectID":"/mysql_grammer/:38:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"查看视图 1. 语法 desc视图名; 或者 showcreateview视图名; ","date":"2021-06-18","objectID":"/mysql_grammer/:39:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"视图内容的更新 1. 插入 同表的插入语法一致。 会更新原始表。 2. 修改 同表的修改语法一致。 会更新原始表。 3. 删除 使用delete语法。 会更新原始表。 4. 说明 视图的可更新性和视图中查询的定义有关系，以下类型的视图不能更新： 包含关键字：分组函数、distinct、group by、having、union、union all 常量视图 select子句中包含子查询 join（某些条件下可更新） from一个不能更新的视图 where子句的子查询引用了from子句中的表 ","date":"2021-06-18","objectID":"/mysql_grammer/:40:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"变量 1. 系统变量 全局变量 会话变量 2. 自定义变量 用户变量 局部变量 ","date":"2021-06-18","objectID":"/mysql_grammer/:41:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"系统变量 1. 含义 变量由系统提供，属于服务器层面。 2. 语法 查看所有的系统变量 showglobal|[session]variables; 查看满足条件的部分系统变量 showglobal|[session]variableslike'%char%'; 查看指定的某个系统变量的值 select@@global.|[session.]系统变量名; 为某个系统变量赋值 setglobal|[session]系统变量名=值; 或者 set@@global.|[session.]系统变量名=值; 3. 注意 如果是全局级别，需要使用global 如果是会话级别，需要加session或者什么都不加 全局变量不能跨重启，即服务器重启后变量值恢复默认 ","date":"2021-06-18","objectID":"/mysql_grammer/:42:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"自定义变量 1. 含义 用户自定义的，不是系统提供的。 2. 用户变量 作用域：当前会话（连接）有效。 声明并初始化： set @变量名=值; 或者 set @变量名:=值; 又或者 select @变量名:=值; 赋值： set@变量名=值;set@变量名:=值;select@变量名:=值; 或者 select字段into@变量名from表; 使用 select@变量名; 3. 局部变量 作用域：仅仅在定义它的begin end中有效 声明： declare变量名类型; 或者 declare变量名类型default值; 赋值： set变量名=值;set变量名:=值;select@变量名:=值; 或者 select字段into变量名from表; 使用： select变量名; 应用： begin中的第一句话。 ","date":"2021-06-18","objectID":"/mysql_grammer/:43:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"存储过程 1. 好处 提高了代码的重用性 简化操作 减少了编译次数，减少了和服务器的连接次数，提高了效率 2. 含义 一组预先编译好的sql语句的集合。 3. 创建 createprocedure过程名(参数列表)begin存储过程体end 注意： 参数列表包含三部分：参数模式、参数名、参数类型 参数模式： IN：输入 OUT：输出 INOUT：输入和输出 如果存储过程体只有一句话，begin、end可以省略。 存储过程体每句都以分号结束。 存储过程体的结尾使用delimiter重新设置。 4. 调用 call存储过程名(实参列表); 5. 删除 DROPPROCEDURE过程名; 6. 查看 SHOWCREATERPROCEDURE过程名 7. 修改 存储过程无法修改。 8. 示例 无参 #定义 DELIMITER$CREATEPROCEDUREmyp1()BEGININSERTINTOadmin(username,`password`)VALUES('john1','0000'),('lily','0000');END$#调用 CALLmyp1()$ IN DELIMITER$CREATEPROCEDUREmyp2(INbeautyNameVARCHAR(20))BEGINSELECTbo.*FROMboysboRIGHTJOINbeautybONbo.id=b.boyfriend_idWHEREb.name=beautyNameEND$ IN #定义 DELIMITER$CREATEPROCEDUREmyp4(INusernameVARCHAR(20),INPASSWORDVARCHAR(20))BEGINDECLAREresultINTDEFAULT0;SELECTCOUNT(*)INTOresultFROMadminWHEREadmin.username=usernameANDadmin.password=PASSWORD;SELECTIF(result\u003e0,'成功','失败');END$#调用 CALLmyp4('张飞','8888')$ OUT #定义 DELIMITER$CREATEPROCEDUREmyp5(INbeautyNameVARCHAR(20),OUTboyNameVARCHAR(20))BEGINSELECTbo.boyNameINTOboyNameFROMboysboINNERJOINbeautybONbo.id=b.boyfriend_idWHEREb.name=beautyName;END$#调用 [SET@bName$]CALLmyp5('小昭',@bName)$SELECT@bName$ INOUT #定义 DELIMITER$CREATEPROCEDUREmyp6(INOUTaINT,INOUTbINT)BEGINSETa=a*2SETb=b*2END$#调用 SET@m=10$SET@n=20$CALLmyp6(@m,@n)$ ","date":"2021-06-18","objectID":"/mysql_grammer/:44:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"函数 函数和好处同存储过程。 1. 说明 有且仅有一个返回。 2. 创建 CREATEFUNCTION函数名（参数列表）RETURNS返回类型BEGIN函数体END 注意： 参数列表包含两部分：参数名 参数类型。 函数体中必须包含return。 函数体仅有一句话，则可以省略begin和end。 使用delimiter语句设置结束标记。 2. 调用 SELECT函数名（参数列表） 3. 查看函数 SHOWCREATEFUNCTION函数名; 4. 删除函数 DROPFUNCTION函数名; 5. 示例 无参有返回 DELIMITER$CREATEFUNCTIONmyf1()RETURNSINTBEGINDECLAREcINTDEFAULT0;SELECTCOUNT(*)INTOcFROMemployees;RETURNc;END$SELECTmyf1()$ 有参有返回 DELIMITER$CREATEFUNCTIONmyf2(empNameVARCHAR(20))RETURNSDOUBLEBEGINSET@sal=0;SELECTsalaryINTO@salFROMemployeesname=empName;RETURN@salEND$SELECTmyf2('tom')$ ","date":"2021-06-18","objectID":"/mysql_grammer/:45:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"流程控制结构 1. 顺序结构 程序从上往下依次执行 2. 分支结构 从多条路径中选择一条去执行 3. 循环结构 在满足一定条件的基础上，重复执行一段代码 ","date":"2021-06-18","objectID":"/mysql_grammer/:46:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"分支结构 1. if函数 IF(表达式1，表达式2，表达式3) 如果表达式1成立，则if函数返回表达式2的值，否则返回表达式3的值。 2. case结构 CASE变量|表达式|字段WHEN要判断的值THEN返回的值1或语句;WHEN要判断的值THEN返回的值2或语句;...ELSE要返回的值n或语句;END; 或者 CASEWHEN要判断的条件1THEN返回的值1或语句;WHEN要判断的条件2THEN返回的值2或语句;...ELSE要返回的值n或语句;ENDCASE; 3. if结构 if条件1then语句1;elseif条件2then语句2;...else语句n;endif; 应用在begin/end中。 4. 示例 case DELIMITER$CREATEPROCEDUREtest_case(INscoreINT)BEGINCASEWHENscore\u003e=90ANDscore\u003c=100THENSELECT'A';WHENscore\u003e=80THENSELECT'B';WHENscore\u003e=60THENSELECT'C';ELSESELECT'D';ENDCASE;END$ if结构 DELIMITER$CREATEFUNCTIONtest_if(scoreINT)RETURNSCHARBEGINIFscore\u003e=90ANDscore\u003c=100THENRETURN'A';ELSEIFscore\u003e=80THENRETURN'B';ELSERETURN'D';ENDIF;END$ ","date":"2021-06-18","objectID":"/mysql_grammer/:47:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"循环结构 1. 分类 while loop repeat 1. 循环控制语句 iterate 类似于 continue leave 类似于 break 2. 语法 [标签:]while循环条件do循环体;endwhile[标签]; [标签:]loop循环体;endloop[标签]; [标签:]repeat循环体;until结束循环的条件endrepeat[标签]; ","date":"2021-06-18","objectID":"/mysql_grammer/:48:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"MySQL语句处理顺序 FROM\u003cleft_table\u003eON\u003cjoin_condition\u003e\u003cjoin_type\u003eJOIN\u003cright_table\u003eWHERE\u003cwhere_condition\u003eGROUPBY\u003cgroup_by_list\u003eHAVING\u003chaving_condition\u003eSELECTDISTINCT\u003cselect_list\u003eORDERBY\u003corder_by_condition\u003eLIMIT\u003climit_number\u003e ","date":"2021-06-18","objectID":"/mysql_grammer/:49:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"join语句汇总 INNER JOIN SELECT\u003cselect_list\u003eFROMtableAINNERJOINtableBONA.key=b.key; LEFT JOIN SELECT\u003cselect_list\u003eFROMtableALEFTJOINtableBONA.key=B.key; RIGHT JOIN SELECT\u003cselect_list\u003eFROMtableARIGHTJOINtableBONA.key=B.key; LEFT JOIN SELECT\u003cselect_list\u003eFROMtableALEFTJOINtableBONA.key=B.keyWHEREB.keyISNULL; RIGHT JOIN SELECT\u003cselect_list\u003eFROMtableARIGHTJOINtableBONA.key=B.keyWHEREA.keyISNULL; FULL OUTER JOIN SELECT\u003cselect_list\u003eFROMtableAFULLOUTERJOINtableBONA.key=B.key; FULL OUTER JOIN SELECT\u003cselect_list\u003eFROMtableAFULLOUTERJOINtableBONA.key=B.keyWHEREA.keyISNULLorB.keyISNULL; ","date":"2021-06-18","objectID":"/mysql_grammer/:50:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"不需要创建索引的情况 表记录太少 频繁更新的字段不适合创建索引。 如果某个数据列包含许多重复内容，建立索引则没有什么实际效果。索引的选择性是指索引列中不同值的数据与表中记录数的比。一个索引的选择性越接近1，这个索引的效率就越高。 ","date":"2021-06-18","objectID":"/mysql_grammer/:51:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"mysql分层和引擎 1. 分层 连接层：提供与客户端连接的服务。 服务层：提供各种用户使用的接口；提供SQL优化器（mysql query optimizer）； 引擎层：提供了数据存储的方式（MyISAM，InnoDB等）； 存储层：存储数据。 2. MyISAM与InnoDB MyISAM不支持主外键；InnoDB支持主外键。 MyISAM不支持事务；InnoDB支持事务。 MyISAM使用表锁，即使操作一条记录也会锁住整个表，不适合高并发操作；InnoDB使用行锁，操作时只锁一行，不对其他行有影响，适合高并发的操作。 MyISAM只缓存索引，不缓存真实数据；InnoDB不仅缓存索引还缓存真实数据，对内存要求较高，并且内存大小对性能有决定性影响。 MyISAM表空间小；InnoDB表空间大。 MyISAM关注性能；InnoDB关注事务。 MyISAM默认安装；InnoDB默认安装；（安装不代表默认使用）。 3. 数据库引擎 支持哪些引擎： showengines; 正在使用的引擎： showvariableslike'%storage_engine%'; 修改引擎： createtabletb(idint(4)auto_increment,namevarchar(5),deptvarchar(5),primarykey(id))engine=MyISAMauto_increment=1defaultcharset=utf8; ","date":"2021-06-18","objectID":"/mysql_grammer/:52:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"sql优化 1. 需要优化的原因 性能低、执行时间太长、等待时间太长、SQl语句欠佳（连接查询）、索引失效、服务器参数设置不对等。 2. sql 编写过程：select ... from ... join ... on ... where ... group by ... having ... order by ... limit 解析过程：from ... on ... join ... where ... group by ... having ... select ... order by limit ... 3. 优化 主要就是在优化索引。 ","date":"2021-06-18","objectID":"/mysql_grammer/:53:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"索引 1. 说明 相当于书的目录。 是帮助MySQL高效获取数据的数据结构。 即索引是数据结构（树：B树（默认）、Hash树。。。） B树：小的节点放左边，大的节点在右边。一般都是指B+树，数据全部存放在叶节点中。B+树查询任意数据的次数都是n次（B+树的高度）。 2. 索引弊端 索引本身很大，可以存放在内存/硬盘。 索引不是所有情况均适用：少量数据；频繁更新的字段；很少适用的字段等。 索引会降低增删改的效率。 3. 索引好处 提高查询效率（降低IO使用率）。 降低CPU使用率（因为B树索引本身就是一个排好序的结构，因此在对数据排序时可以直接使用）。 4. 分类 主键索引：列值不能重复，且不能为null 单值索引：单列构成的索引。一个表可以有多个单值索引。 唯一索引：构成唯一索引的列数据不能重复。 复合索引：多个列构成的索引。 ","date":"2021-06-18","objectID":"/mysql_grammer/:54:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"创建索引 1. 方式一 create索引类型索引名on表（字段） 示例： 单值 createindexdept_indexontbl(dept); 唯一 createuniqueindexname_indexontbl(name); 复合 createindexdept_name_indexontbl(dept,name); 2. 方式二 altertable表名add索引类型索引名(字段) 示例： 单值 altertabletbladdindexdept_index(dept); 唯一 altertabletbladduniqueindexname_index(name); 多值 altertabletbladdindexdept_name_index(dept,name); 3. 注意 如果一个字段是 primary key，则该字段默认就是主键索引。 ","date":"2021-06-18","objectID":"/mysql_grammer/:55:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"删除索引 dropindex索引名on表名; 示例： dropindexname_indexontbl; ","date":"2021-06-18","objectID":"/mysql_grammer/:56:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"查看索引 showindexfrom表名; 或者 showindexfrom表名\\G ","date":"2021-06-18","objectID":"/mysql_grammer/:57:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"SQL性能问题 1. 说明 主要是通过分析SQL执行计划，分析性能。 注意，SQL查询优化器会干扰我们的优化。 ","date":"2021-06-18","objectID":"/mysql_grammer/:58:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"SQL执行计划 1. 语法 explain+SQL语句 ","date":"2021-06-18","objectID":"/mysql_grammer/:59:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"执行计划分析 1. 表的执行顺序，因数量的改变而改变 原因：笛卡尔积。 数据量小的表，优先查询。 1. id id相同，从上往下顺序执行。 id不同，id值越大越优先查询（原因：在嵌套子查询时，先查内层，再查外层）。 id值有相同，又有不同，id值越大越优先，id值相同从上往下顺序执行。 2. select_type Primary：包含子查询SQL中的主查询（最外层）。 Subquery：包含子查询SQL中的子查询（非最外层）。 Simple：简单查询（不包含子查询、union）。 derived：衍生查询（使用到了临时表）；如在from子查询中只有一张表；又或者在from子查询中，如果有table1 union table2，则table1就是derived，table2就是union。 union：说明见上例。 union result：告知哪些表之间存在union查询。 3. table 4. type System \u003e const \u003e eq_ref \u003e ref \u003e range \u003e index \u003e all 其中：system，const只是理想情况，实际能达到 ref \u003e range。 优化前提：有索引。 system（忽略） 只有一条数据的系统表；或衍生表只有一条数据的主查询。 const 仅仅能查到一条数据的SQL，用于primary key或者unique索引（类型与索引类型有关）。 eq_ref 唯一性索引；对于每个索引键的查询，返回匹配的唯一行数据（有且只有1个，不能为0）；常见于唯一索引和主键索引。 ref 非唯一性索引，对于每个索引键的查询，返回匹配的所有行。 range 检索指定范围的行。 index 查询全部索引表中的数据。 all 查询表中的所有数据。 5. Possible_keys 可能用到的索引，是一种预测。 6. key 实际用到的索引。 7. key_len 索引的长度。 用于判断复合索引是否被完全使用。 对于utf8，一个字符占3个字节。 如果索引字段可以为null，则会使用1个字节用于标识。 如果索引字段为varchar，使用2个字节标识可变长度。 8. ref 注意与type中的ref值区分。 作用：指明当前表所参照的字段。 如：select ... where a.c = b.x; 9. rows 被索引优化查询的数据个数（实际通过索引而查询到的数据个数）。 10. extra using filesort 性能消耗大；需要“额外”一次排序（查询）。常见于order by语句中。 示例1： explainselect*fromtestwherea1=''orderbya2; 小结：对于单索引，如果排序和查找是同一个字段，则不会出现using filesort；如果排序和查找不是同一个字段，则会出现using filesort。 示例2：（注意存在a1, a2, a3, a4四个字段） altertabletestaddindexidx_a1_a2_a3(a1,a2,a3);explainselect*fromtestwherea1=''orderbya3;# using filesort explainselect*fromtestwherea2=''orderbya3;# using filesort explainselect*fromtestwherea1=''orderbya2; 小结：对于复合索引，where和order by按照复合索引的顺序使用，不要跨列或无序使用。 using temporary 性能损耗大，用到了临时表。一般出现在group by语句中。 示例： explainselect*fromtestwherea1in(1,2,3)groupbya1;explainselect*fromtestwherea1in(1,2,3)groupbya2;# using temporary using index 性能提升，常见于索引覆盖。 只要使用到的列，全部都在索引中，就称为”索引覆盖“。 不读取原文件，只从索引文件中获取数据（不需要回表查询）。 索引覆盖会对possible_keys和key造成影响：如果没有where，则索引只出现在key中；如果有where，则索引可能出现在key和possible_keys中。 using where 回表查询时，会出现using where。 impossible where where子句永远为false。 using join buffer mysql引擎使用了连接缓存。 ","date":"2021-06-18","objectID":"/mysql_grammer/:60:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"SQL优化 SQL优化是一种概率层面的优化。 服务层有SQL优化器，可能会影响我们的优化。 ","date":"2021-06-18","objectID":"/mysql_grammer/:61:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"单表优化 最佳左前缀，保持索引的定义和使用的顺序一致性 索引要逐步优化 将含in的范围查询，放到where的最后，防止失效 ","date":"2021-06-18","objectID":"/mysql_grammer/:62:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"双表优化 小表驱动大表 一般情况下，左外连接，给右表加索引；右外连接，给左表加索引。 ","date":"2021-06-18","objectID":"/mysql_grammer/:63:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"三表优化 小表驱动大表。 索引建立在经常查询的字段上。 ","date":"2021-06-18","objectID":"/mysql_grammer/:64:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"避免索引失效的一些原则 复合索引，不要跨列或无序使用（最佳左前缀）。 复合索引，尽量使用全索引匹配。 不要在索引上进行任何操作（计算，函数，类型转换），否则索引失效。 复合索引不能使用”不等于“，否则自身以及右侧所有全部失效。 复合索引中如果有\u003e，自身和右侧全失效。 一般而言，范围查询之后的索引失效。 尽量使用覆盖索引。 like尽量以“常量”开头，不要以\"%“开头，否则索引失效。 尽量不要使用类型转换。 尽量不要使用or，否则索引失效。 ","date":"2021-06-18","objectID":"/mysql_grammer/:65:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"其他的一些优化方法 order by using filesort有两种算法：单路排序、双路排序。 双路排序扫描两次磁盘：从磁盘读取排序字段；读取其他字段。 单路排序扫描一次磁盘：读取全部字段（不一定真的是单次，有可能是多次IO）。 Mysql4.1之前默认使用双路排序；mysql4.1之前默认使用单路排序。 设置buffer的容量大小：set max_length_for_sort_data = 1024，单位byte。 如果max_length_for_sort_data值太低，mysql会自动从 单路切换成双路。 避免使用select * ... 复合索引不要跨列使用。 保证排序字段的排序一致性。 ","date":"2021-06-18","objectID":"/mysql_grammer/:66:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"慢查询 mysql提供的一种日志记录，用于记录mysql响应超过阀值的语句，默认10秒。 默认是关闭的；建议调优时打开，最终部署时关闭。 检查是否打开了慢查询日志： showvariableslike'%slow_query_log%'; 临时开启： setglobalslow_query_log=1; mysql服务器重启后会失效。 永久开启： #/etc/my.cnf追加 [mysqld] slow_query_log=1 slow_query_log_file=/var/lib/mysql/local-slow.log 慢查询阀值： showvariableslike\"%log_query_time%\"; 设置慢查询阀值： setgloballomg_query_time=5; 重新登陆后生效。 永久设置阀值： #在/etc/my.cnf追加 [mysqld] long_query_time=3 查询超过阀值的sql： showglovalstatuslike'%slow_queries%'; ","date":"2021-06-18","objectID":"/mysql_grammer/:67:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"mysqldumpslow 用于查看慢SQL。 ","date":"2021-06-18","objectID":"/mysql_grammer/:68:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"海量数据分析 1. profiles 查看开启状态 showvariableslike'%profiling%'; 打开 setprofiling=on; 查看profiling打开之后，全部sql查询语句所花时间，不够精确 showprofiles; 2. 精确分析 showprofileallforquery上一步查询的query_id; 或者 showprofilecpu,blockioforquery上一步查询的query_id; 3. 全局查询日志 记录开启之后的全部sql语句，仅仅在调优、开发过程中打开。 showvariableslike'%general_log%';# 查看状态 #记录在表中 setglobalgeneral_log=1;# 开启 setgloballog_output='table';# sql记录在表中 #或者记录在文件中 setglobalgeneral_log=1;# 开启 setgloballog_output='file';# 或者sql记录在文件中 setglobalgeneral_log_file='/tmp/general.log';# 或者sql记录在文件中 ","date":"2021-06-18","objectID":"/mysql_grammer/:69:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"锁机制 解决因资源共享，造成的并发问题。 分类 按照操作类型： 读锁（共享锁）：对同一个数据，多个读操作可以同时进行，互不干扰。 写锁（互斥锁）：如果当前写操作没有完毕，则无法进行其他的读、写。 按照操作范围： 表锁：一次性对一张表整体加锁。MyISAM使用表锁。开销小，加锁快，无死锁。但锁的范围大，容易发生锁冲突，并发度低。 行锁：一次性对一条数据加锁。InnoDB使用行锁。开销大，加锁慢，容易死锁。所得范围较小，不容易发生锁冲突，并发度高，很小概率发生高并发问题（脏读、幻读、不可重复读）。 页锁： ","date":"2021-06-18","objectID":"/mysql_grammer/:70:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"表锁 给表加锁 locktable表1read/write,表2read/write,...; 查看加锁的表 showopentables; 释放锁 unlocktables; 加读锁的机制 如果一个会话对A表加了read锁，则该会话可以对A表进行读操作、不能进行写操作；不能对其它表进行读写操作。其它会话可以对A表进行读操作、进行写操作得等待锁释放；对其他表可以进行读写操作。 加写锁的机制 某个会话对表加写锁，之后可以对这张表进行任何操作，但是不能操作其它表。 其他会话对加写锁的表，进行增删改查时得等待锁释放。 MySQL表级锁的锁模式 MyISAM在执行查询语句前，会自动给涉及到的所有表加读锁；在执行更新操作前，会自动给涉及的表加写锁。 对MyISAM表的读操作，不会阻塞其他进程（会话）对同一表的读请求，会阻塞对同一表的写请求。 对MyISAm表的写操作，会阻塞其他进程（会话）对同一表的读和写操作，只有当锁释放时，才会进行其它进程的读写操作。 分析表锁定 查看表锁定状态 showopentables;# 1代表加了锁 分析表锁定的严重程度 showstatuslike'table%'; table_lock_immediate：可能获取到的锁数。 tale_locks_waited：需要等待的表锁数，该值越大，锁竞争越大。 当table_locks_immediate / table_locks_waited \u003e 5000，建议采用InnoDB引擎。 ","date":"2021-06-18","objectID":"/mysql_grammer/:71:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"行锁 InnoDB默认采用行锁。 研究前提：关闭了自动commit 关闭语句： set autocommit=0 start transection begin 总结： 如果”会话1“对“某条数据a”进行了DML操作，则其他会话需要等待“会话1”对“数据a”提交事务。 行锁通过事务解锁。 不同会话对不同行数据进行操作，互不影响。 查询数据不会加锁。 可以通过for update对query语句进行加锁。 注意事项： 如果没有索引，行锁会转换为表锁，需要通过commit进行解锁。 行锁的一种特殊情况： 间隙锁：值在范围内，但却不存在。 如：update ... where id \u003e 1 and id \u003c 9;，如果id=7的数据不存在，则该行数据存在间隙锁。 如果有where，则实际加锁的范围是where后面的范围（不是实际的值）。 缺点： 比表锁性能损耗大。 优点： 并发能力强，效率高。 行锁分析 查看行锁状态 showstatuslike'%innodb_row_lock%' Innodb_row_locl_current_waits：当前正在等待锁的数量。 Innodb_row_lock_time：等待总时长，从系统启动到现在，一共等待的时间。 Innodb_row_lock_time_avg：平均等待时长，从系统启动到现在的平均等待时间。 Innodb_row_lock_time_max：最大等待时长，从系统启动到现在的最大等待时间。 Innodb_row_lock_waits：从系统启动到现在，等待的次数。 ","date":"2021-06-18","objectID":"/mysql_grammer/:72:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"主从复制 优点 负载均衡 失败迁移 原理 master将改变的数据记录在本地的二进制日志中（binary log）；该过程称为“二进制日志事件”。 slave将master的binary log拷贝到relay log（中继日志文件）中。 slave将数据从relay log读取到自己的数据库中，称为中继日志事件。 特点 异步 串行话 有延迟 ","date":"2021-06-18","objectID":"/mysql_grammer/:73:0","tags":["MySQL"],"title":"MySQL 基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"预读机制 预读机制是相对于Innodb存储引擎而言的。 所谓预读机制，就是在加载数据页时，可能会将相邻数据页一起预先加载到buffer pool中，之后读取时就可以直接从内存获取，不必从磁盘读入。 使用Innodb的预读机制，可以减少磁盘IO次数，提高读写性能。 ","date":"2021-06-13","objectID":"/mysql_innodb_read_ahead/:1:0","tags":["MySQL"],"title":"MySQL 预读机制","uri":"/mysql_innodb_read_ahead/"},{"categories":["MySQL"],"content":"预读模式 Innodb一共提供了两种预读模式： 线性预读：判断当前extend中的数据是否被连续访问，从而决定是否把下一个extend从磁盘中读出来，加载到buffer pool。 随机预读：判断当前extend中读取page的个数，从而决定是否把当前extend的数据加载到buffer pool中。 ","date":"2021-06-13","objectID":"/mysql_innodb_read_ahead/:2:0","tags":["MySQL"],"title":"MySQL 预读机制","uri":"/mysql_innodb_read_ahead/"},{"categories":["MySQL"],"content":"线性预读 MySQL5.5之后，默认使用的是线性预读模式，与之有关的配置为innodb_read_ahead_threshold，这个参数表示，当前extend中，如果有超过innodb_read_ahead_threshold个page被连续访问，就预先加载下一个extend的数据。 innodb_read_ahead_threshold的默认参数是56，最大为64，最小为0。如果为0，表示关闭线性预读。即使关闭了线性预读，只要随机预读没有显式打开，就不会使用它。 innodb组织数据的顺序为tablespace, segment, extend, page, row，因为extend固定为1Mb，page默认为16Kb，所以一个extend能容纳64个page，所以innodb_read_ahead_threshold最大为64。 ","date":"2021-06-13","objectID":"/mysql_innodb_read_ahead/:3:0","tags":["MySQL"],"title":"MySQL 预读机制","uri":"/mysql_innodb_read_ahead/"},{"categories":["MySQL"],"content":"预读原理 连续访问，是根据page的最新一次访问时间来判断的。 如果当前page是extend的第一个，则看后面的63个page，如果访问时间连续递减的个数，大于等于innodb_read_ahead_threshold，就加载上一个extend。 如果当前page是extend的最后一个，则看前面的63个page，如果访问时间连续递增的个数，大于等于innodb_read_ahead_threshold，就加载下一个extend。 ","date":"2021-06-13","objectID":"/mysql_innodb_read_ahead/:3:1","tags":["MySQL"],"title":"MySQL 预读机制","uri":"/mysql_innodb_read_ahead/"},{"categories":["MySQL"],"content":"随机预读 MySQL5.5之后，随机预读是默认关闭的。 与随机预读有关的配置为innodb_random_read_ahead。 ","date":"2021-06-13","objectID":"/mysql_innodb_read_ahead/:4:0","tags":["MySQL"],"title":"MySQL 预读机制","uri":"/mysql_innodb_read_ahead/"},{"categories":["Golang"],"content":"介绍 golang提供了文件相关的各种操作，包括创建、删除、和读写等。 ","date":"2021-06-06","objectID":"/golang_file/:1:0","tags":["Golang","file"],"title":"golang文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"文件基本操作方法 ","date":"2021-06-06","objectID":"/golang_file/:2:0","tags":["Golang","file"],"title":"golang文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"1. 查看文件信息 func main() { // 查看文件信息 fileInfo, err := os.Stat(\"./data.txt\") if err != nil { fmt.Println(err) return } fmt.Println(\"Stat:\", fileInfo.Name()) fmt.Println(\"Stat:\", fileInfo.IsDir()) fmt.Println(\"Stat:\", fileInfo.Size()) fmt.Println(\"Stat:\", fileInfo.Mode()) fmt.Println(\"Stat:\", fileInfo.ModTime()) } ","date":"2021-06-06","objectID":"/golang_file/:2:1","tags":["Golang","file"],"title":"golang文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"2. 路径操作 func main() { // 路径操作 filename1 := \"./file.txt\" fmt.Println(\"IsAbs:\", filepath.IsAbs(filename1)) // 获取绝对路径 fileabs, err := filepath.Abs(filename1) if err != nil { log.Fatal(err) } fmt.Println(fileabs) // 绝对路径的父级目录 fmt.Println(\"Join:\", path.Join(fileabs, \"..\")) } ","date":"2021-06-06","objectID":"/golang_file/:2:2","tags":["Golang","file"],"title":"golang文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"3. 创建一级文件夹 func main() { // 创建一级文件夹 err := os.Mkdir(\"./aa\", os.ModePerm) if err != nil { fmt.Println(err) } } ","date":"2021-06-06","objectID":"/golang_file/:2:3","tags":["Golang","file"],"title":"golang文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"4. 创建多级文件夹 func main() { // 创建多级文件夹 err := os.MkdirAll(\"./bb/cc\", os.ModePerm) if err != nil { fmt.Println(err) } } ","date":"2021-06-06","objectID":"/golang_file/:2:4","tags":["Golang","file"],"title":"golang文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"5. 创建文件 func main() { // 创建文件，权限默认为0666，如果文件存在，会清空数据 file, err := os.Create(\"./file.txt\") if err != nil { fmt.Println(err) return } file.Close() } ","date":"2021-06-06","objectID":"/golang_file/:2:5","tags":["Golang","file"],"title":"golang文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"5. 只读模式打开文件 func main() { // 只读模式打开文件 file, err := os.Open(\"./file.txt\") if err != nil { fmt.Println(err) return } file.Close() } ","date":"2021-06-06","objectID":"/golang_file/:2:6","tags":["Golang","file"],"title":"golang文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"6. 以指定模式打开文件 func main() { // 以指定模式打开文件，如果文件不存在，则以指定权限0666创建文件 file, err := os.OpenFile(\"./file.txt\", os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0666) if err != nil { fmt.Println(err) return } file.Close() } ","date":"2021-06-06","objectID":"/golang_file/:2:7","tags":["Golang","file"],"title":"golang文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"7. 删除空目录或文件 func main() { // 删除空目录 err := os.Remove(\"./aa\") if err != nil { fmt.Println(\"remove:\", err) return } // 删除文件 err = os.Remove(\"./file.txt\") if err != nil { fmt.Println(\"remove:\", err) return } } ","date":"2021-06-06","objectID":"/golang_file/:2:8","tags":["Golang","file"],"title":"golang文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"8. 删除指定目录或文件，即使目录非空 func main() { // 删除所有目录，包括非空目录 err := os.RemoveAll(\"./aa.txt\") if err != nil { fmt.Println(\"RemoveAll:\", err) return } err = os.RemoveAll(\"./data.txt\") if err != nil { fmt.Println(\"RemoveAll:\", err) return } } ","date":"2021-06-06","objectID":"/golang_file/:2:9","tags":["Golang","file"],"title":"golang文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"读取文件内容 除了上述的文件基本操作外，golang还为读文件提供了多种方式。 ","date":"2021-06-06","objectID":"/golang_file/:3:0","tags":["Golang","file"],"title":"golang文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"file.Read func main() { file, err := os.Open(\"./data.txt\") if err != nil { log.Fatal(err) } defer file.Close() b := make([]byte, 128) for { n, err := file.Read(b) if err == io.EOF { break } if err != nil { log.Fatal(err) } fmt.Printf(\"%s\", string(b[:n])) } } ","date":"2021-06-06","objectID":"/golang_file/:3:1","tags":["Golang","file"],"title":"golang文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"io.ReadFull 1 package main 2 3 import ( 4 \"fmt\" 5 \"io\" 6 \"log\" 7 \"os\" 8 ) 9 10 func main() { 11 file, err := os.Open(\"./data.txt\") 12 if err != nil { 13 log.Fatal(err) 14 } 15 defer file.Close() 16 17 // 读取正好1024个字节，内容不够会报错 18 b := make([]byte, 1024) 19 n, err := io.ReadFull(file, b) 20 if err != nil { 21 log.Fatal(err) 22 } 23 24 fmt.Printf(\"%s\", string(b[:n])) 25 } ","date":"2021-06-06","objectID":"/golang_file/:3:2","tags":["Golang","file"],"title":"golang文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"io.ReadAtLeast func main() { file, err := os.Open(\"./data.txt\") if err != nil { log.Fatal(err) } defer file.Close() // 至少读取8个字节，不够的话会报错 b := make([]byte, 1024) n, err := io.ReadAtLeast(file, b, 8) if err != nil { log.Fatal(err) } fmt.Printf(\"%s\", string(b[:n])) } ","date":"2021-06-06","objectID":"/golang_file/:3:3","tags":["Golang","file"],"title":"golang文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"bufio.NewReader bufio提供了多种读取文件的方法，但方法名都是以Read开头。 func main() { file, err := os.Open(\"./data.txt\") if err != nil { log.Fatal(err) } defer file.Close() reader := bufio.NewReader(file) for { str, err := reader.ReadString('\\n') if err == io.EOF { break } if err != nil { log.Fatal(err) } fmt.Printf(\"%s\", str) } } ","date":"2021-06-06","objectID":"/golang_file/:3:4","tags":["Golang","file"],"title":"golang文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"ioutil.ReadAll func main() { file, err := os.Open(\"./data.txt\") if err != nil { log.Fatal(err) } defer file.Close() data, err := ioutil.ReadAll(file) if err != nil { log.Fatal(err) } fmt.Printf(\"%s\", string(data)) } ","date":"2021-06-06","objectID":"/golang_file/:3:5","tags":["Golang","file"],"title":"golang文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"ioutil.ReadFile func main() { b, err := ioutil.ReadFile(\"./data.txt\") if err != nil { log.Fatal(err) } fmt.Println(string(b)) } ","date":"2021-06-06","objectID":"/golang_file/:3:6","tags":["Golang","file"],"title":"golang文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"bufio.NewScanner func main() { file, err := os.Open(\"./data.txt\") if err != nil { log.Fatal(err) } defer file.Close() scanner := bufio.NewScanner(file) for scanner.Scan() { fmt.Println(scanner.Text()) } err = scanner.Err() if err != nil { log.Fatal(err) } } ","date":"2021-06-06","objectID":"/golang_file/:3:7","tags":["Golang","file"],"title":"golang文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"写入文件 golang为写文件提供了以下方式。 ","date":"2021-06-06","objectID":"/golang_file/:4:0","tags":["Golang","file"],"title":"golang文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"file.Write func main() { file, err := os.OpenFile(\"./data.txt\", os.O_WRONLY|os.O_CREATE, 0644) if err != nil { log.Fatal(err) } defer file.Close() b := []byte(\"Hello\") n, err := file.Write(b) if err != nil { log.Fatal(err) } fmt.Printf(\"Wrote %d bytes.\\n\", n) } ","date":"2021-06-06","objectID":"/golang_file/:4:1","tags":["Golang","file"],"title":"golang文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"ioutil.WriteFile func main() { err := ioutil.WriteFile(\"./data.txt\", []byte(\"Hello\"), 0644) if err != nil { log.Fatal(err) } } ","date":"2021-06-06","objectID":"/golang_file/:4:2","tags":["Golang","file"],"title":"golang文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"bufio.NewWriter bufio包中，写入文件的方法较多，但都是以Write开头。 func main() { file, err := os.OpenFile(\"./data.txt\", os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644) if err != nil { log.Fatal(err) } defer file.Close() writer := bufio.NewWriter(file) writer.WriteString(\"Hello world\") writer.Flush() } ","date":"2021-06-06","objectID":"/golang_file/:4:3","tags":["Golang","file"],"title":"golang文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"定义 Buffer是一个可变长的字节缓冲区，具备读写的方法。Buffer的零值是一个空的缓冲区。 type Buffer struct { buf []byte // contents are the bytes buf[off : len(buf)] off int // read at \u0026buf[off], write at \u0026buf[len(buf)] lastRead readOp // last read operation, so that Unread* can work correctly. } ","date":"2021-06-06","objectID":"/golang_buffer_pkg/:1:0","tags":["Golang","buffer"],"title":"golang buffer包的使用","uri":"/golang_buffer_pkg/"},{"categories":["Golang"],"content":"声明 有四种声明方法。 直接定义一个Buffer变量。 var b bytes.Buffer 使用New返回Buffer变量指针。 b := new(bytes.Buffer) 使用[]byte切片初始化。 b := bytes.NewBuffer([]byte(\"hello\")) 使用string初始化。 b := bytes.NewBufferString(\"hello\") ","date":"2021-06-06","objectID":"/golang_buffer_pkg/:2:0","tags":["Golang","buffer"],"title":"golang buffer包的使用","uri":"/golang_buffer_pkg/"},{"categories":["Golang"],"content":"写数据 Buffer提供了5种写数据的方法。 将[]byte切片写入尾部。 func (b *Buffer) Write(p []byte) (n int, err error) 将string写入尾部。 func (b *Buffer) WriteString(s string) (n int, err error) 将字符写入尾部。 func (b *Buffer) WriteByte(c byte) error 将rune写入尾部。 func (b *Buffer) WriteRune(r rune) (n int, err error) 将接口对象写入尾部。 func (b *Buffer) ReadFrom(r io.Reader) (n int64, err error) ","date":"2021-06-06","objectID":"/golang_buffer_pkg/:3:0","tags":["Golang","buffer"],"title":"golang buffer包的使用","uri":"/golang_buffer_pkg/"},{"categories":["Golang"],"content":"读数据 Buffer提供了7种读数据的方法。 读取n个字符。 func (b *Buffer) Next(n int) []byte 将数据读入[]byte。 func (b *Buffer) Read(p []byte) (n int, err error) 读取第一个byte。 func (b *Buffer) ReadByte() (byte, error) 读取第一个UTF8编码字符。 func (b *Buffer) ReadRune() (r rune, size int, err error) 读取分隔符前的内容，并且返回切片。 func (b *Buffer) ReadBytes(delim byte) (line []byte, err error) 读取分隔符前的内容，并且返回字符串。 func (b *Buffer) ReadString(delim byte) (line string, err error) 将内容输出到接口对象。 func (b *Buffer) WriteTo(w io.Writer) (n int64, err error) ","date":"2021-06-06","objectID":"/golang_buffer_pkg/:4:0","tags":["Golang","buffer"],"title":"golang buffer包的使用","uri":"/golang_buffer_pkg/"},{"categories":["Golang"],"content":"其他方法 返回字节切片。 func (b *Buffer) Bytes() []byte 返回字节切片容量。 func (b *Buffer) Cap() int 为容量增加n个字节。 func (b *Buffer) Grow(n int) 返回缓冲区长度。 func (b *Buffer) Len() int 清空数据。 func (b *Buffer) Reset() 字符串化。 func (b *Buffer) String() string 丢弃前n个未读字节以外的数据。 func (b *Buffer) Truncate(n int) 将最后一次成功读取的字节，设为未读取状态。 func (b *Buffer) UnreadByte() error 将最后一次读取的rune字符，设为未读取状态。 func (b *Buffer) UnreadRune() error ","date":"2021-06-06","objectID":"/golang_buffer_pkg/:5:0","tags":["Golang","buffer"],"title":"golang buffer包的使用","uri":"/golang_buffer_pkg/"},{"categories":["Golang"],"content":"bufio包介绍 bufio包可以从文件或标准输入读取数据，还可以向文件中写入数据。 读取数据时，先将数据读入缓冲区，然后再从缓冲区中读取。写入数据时，先把数据写入缓冲区，然后在某个时间节点，一次性地将数据写入文件。 通过缓冲区，能有效减少读写磁盘的次数。 ","date":"2021-06-06","objectID":"/golang_bufio_pkg/:1:0","tags":["Golang","bufio"],"title":"golang bufio包的使用","uri":"/golang_bufio_pkg/"},{"categories":["Golang"],"content":"使用 下面仅介绍一些常见用法。 ","date":"2021-06-06","objectID":"/golang_bufio_pkg/:2:0","tags":["Golang","bufio"],"title":"golang bufio包的使用","uri":"/golang_bufio_pkg/"},{"categories":["Golang"],"content":"1. 读取数据 func main() { file1, err := os.OpenFile(\"./data.txt\", os.O_CREATE|os.O_RDWR, os.ModePerm) if err != nil { log.Fatal(err) } defer file1.Close() // 创建缓冲区，默认大小是4096 buf := bufio.NewReader(file1) b := make([]byte, 64) n, err := buf.Read(b) if err != nil { log.Fatal(err) } fmt.Println(buf.Buffered()) fmt.Println(string(b[:n])) } ","date":"2021-06-06","objectID":"/golang_bufio_pkg/:2:1","tags":["Golang","bufio"],"title":"golang bufio包的使用","uri":"/golang_bufio_pkg/"},{"categories":["Golang"],"content":"2. 按行读取 func main() { file1, err := os.OpenFile(\"./data.txt\", os.O_CREATE|os.O_RDWR, os.ModePerm) if err != nil { log.Fatal(err) } defer file1.Close() // 创建缓冲区，默认大小是4096 buf := bufio.NewReader(file1) // 按行读取 for { bs1, _, err := buf.ReadLine() if err == io.EOF { break } fmt.Println(string(bs1)) } } ","date":"2021-06-06","objectID":"/golang_bufio_pkg/:2:2","tags":["Golang","bufio"],"title":"golang bufio包的使用","uri":"/golang_bufio_pkg/"},{"categories":["Golang"],"content":"3. 读取多个字节 func main() { file1, err := os.OpenFile(\"./data.txt\", os.O_CREATE|os.O_RDWR, os.ModePerm) if err != nil { log.Fatal(err) } defer file1.Close() // 创建缓冲区，默认大小是4096 buf := bufio.NewReader(file1) // 指定每次读取的分割符 for { bs2, err := buf.ReadBytes('\\n') if err == io.EOF { break } fmt.Print(string(bs2)) } } ","date":"2021-06-06","objectID":"/golang_bufio_pkg/:2:3","tags":["Golang","bufio"],"title":"golang bufio包的使用","uri":"/golang_bufio_pkg/"},{"categories":["Golang"],"content":"4. 读取字符串 func main() { file1, err := os.OpenFile(\"./data.txt\", os.O_CREATE|os.O_RDWR, os.ModePerm) if err != nil { log.Fatal(err) } defer file1.Close() // 创建缓冲区，默认大小是4096 buf := bufio.NewReader(file1) for { str, err := buf.ReadString('\\n') if err != nil { break } fmt.Print(str) } } ","date":"2021-06-06","objectID":"/golang_bufio_pkg/:2:4","tags":["Golang","bufio"],"title":"golang bufio包的使用","uri":"/golang_bufio_pkg/"},{"categories":["Golang"],"content":"5. 从标准输入读取 func main() { // 读取输入 buf := bufio.NewReader(os.Stdin) for { s2, _, err := buf.ReadLine() fmt.Println(string(s2)) fmt.Println(err) if string(s2) == \"q\" { break } } } ","date":"2021-06-06","objectID":"/golang_bufio_pkg/:2:5","tags":["Golang","bufio"],"title":"golang bufio包的使用","uri":"/golang_bufio_pkg/"},{"categories":["Golang"],"content":"6. 写入数据到文件 func main() { // 写入数据 file, err := os.OpenFile(\"./data1.txt\", os.O_CREATE|os.O_RDWR, os.ModePerm) if err != nil { log.Fatal(err) } buf2 := bufio.NewWriter(file) n, err := buf2.WriteString(\"今夜特别漫长\\n\") if err != nil { log.Fatal(err) } // 将缓冲区数据刷入磁盘文件 buf2.Flush() fmt.Println(n) } ","date":"2021-06-06","objectID":"/golang_bufio_pkg/:2:6","tags":["Golang","bufio"],"title":"golang bufio包的使用","uri":"/golang_bufio_pkg/"},{"categories":["Golang"],"content":"源码解析 ","date":"2021-06-06","objectID":"/golang_bufio_pkg/:3:0","tags":["Golang","bufio"],"title":"golang bufio包的使用","uri":"/golang_bufio_pkg/"},{"categories":["Golang"],"content":"1. bufio.NewReader 用于生成一个读缓冲区。 方法的具体定义为： func NewReader(rd io.Reader) *Reader { return NewReaderSize(rd, defaultBufSize) } 传入的参数rd需要实现io.Reader接口，通过os.Open或者os.OpenFile返回的*File对象就实现了这个接口。 *Reader结构体中包含buf字段，这是一个字节切片，用做缓冲区来存放数据。 defaultBufSize用于定义buf的长度和容量，默认4096个字节。 ","date":"2021-06-06","objectID":"/golang_bufio_pkg/:3:1","tags":["Golang","bufio"],"title":"golang bufio包的使用","uri":"/golang_bufio_pkg/"},{"categories":["Golang"],"content":"2. bufio.Read 方法的声明为： func (b *Reader) Read(p []byte) (n int, err error) 当p的长度为0时，不读取数据。 当缓冲区为空，且p的长度大于等于缓冲区长度时，不经过缓冲区，直接从文件中读取数据。 当缓冲区为空，且p的长度小于缓冲区长度时，先将数据读入缓冲区，再从缓冲区读取需要的字节。 如果缓冲不为空，直接从缓冲区读取，当p读满了，或者缓冲区读空了，就返回结果。 ","date":"2021-06-06","objectID":"/golang_bufio_pkg/:3:2","tags":["Golang","bufio"],"title":"golang bufio包的使用","uri":"/golang_bufio_pkg/"},{"categories":["Golang"],"content":"3. bufio.NewWriter func NewWriter(w io.Writer) *Writer { return NewWriterSize(w, defaultBufSize) } 用于生成一个写缓冲区。逻辑类似于bufio.NewReader，返回一个*Writer结构体地址。 Writer中含有buf字段，用做缓冲区来存放数据，默认长度为4096个字节。 ","date":"2021-06-06","objectID":"/golang_bufio_pkg/:3:3","tags":["Golang","bufio"],"title":"golang bufio包的使用","uri":"/golang_bufio_pkg/"},{"categories":["Golang"],"content":"4. bufio.Write func (b *Writer) Write(p []byte) (nn int, err error) 如果写入的数据大于缓冲区可用长度，当缓冲区内无数据时，直接写入文件。 如果写入数据大于缓冲区可用长度，且缓冲区有数据，则先将数据写入缓冲区，再将缓冲区写入文件并清空缓冲区。不断重复该过程，直到剩余数据不大于缓冲区可用长度，然后仅将数据写入缓冲区，结束。 如果写入数据小于等于缓冲区可用长度，则仅仅写入缓冲区。 ","date":"2021-06-06","objectID":"/golang_bufio_pkg/:3:4","tags":["Golang","bufio"],"title":"golang bufio包的使用","uri":"/golang_bufio_pkg/"},{"categories":["Linux"],"content":"sed编辑器 sed可以根据命令来编辑数据流，大致处理流程为： 从输入读取一行数据。 按照命令对数据进行匹配。 按照命令修改匹配到的数据。 将新的数据输出到STDOUT。 读取下一行数据，并重复上述过程。 数据流读取完毕，则程序终止。 sed命令格式： sed [options] script file options可以是： -e script: 将script中的命令，添加到已有的命令列表。 -f file: 将file中指定的命令，添加到已有的命令列表。 -n：不输出每一行的处理结果。 注意： linux和mac中的sed，语法存在一定差异，本文的测试环境为linux下的bash4.2。 ","date":"2021-06-05","objectID":"/linux_sed/:1:0","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"sed options的基本使用 假设有一个data.txt文件： This is line 1. This is line 2. ","date":"2021-06-05","objectID":"/linux_sed/:2:0","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"1. 常规命令 $ sed 's/line/number/' data.txt this is number 1. this is number 2. s/line/number/是指，将line替换成number。 ","date":"2021-06-05","objectID":"/linux_sed/:2:1","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"2. 使用-e $ sed -e 's/line/number/' -e 's/this/This/' data.txt This is number 1. This is number 2. ","date":"2021-06-05","objectID":"/linux_sed/:2:2","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"3. 使用-f $ cat script.sed s/line/number/ s/this/This/ $ ed -f script.sed data.txt This is number 1. This is number 2. ","date":"2021-06-05","objectID":"/linux_sed/:2:3","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"sed script的基本语法 ","date":"2021-06-05","objectID":"/linux_sed/:3:0","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"1. 替换s 可以使用s命令来替换文本，还可以指定替换标记： s/pattern/replacement/[flags] 替换标记是可选的，具体有以下几种： 数字：表明替换第几处匹配的地方。 $ cat data.txt this is line 1. this is line 2. $ sed 's/is/was/2' data.txt this was line 1. this was line 2. g：替换所有匹配的文本。 $ cat data.txt this is line 1. this is line 2. $ sed 's/is/*/g' data.txt th* * line 1. th* * line 2. p：输出被修改过的行。 $ cat data.txt this is line 1. this is line 2. $ sed 's/line 1/*/p' data.txt this is *. this is *. this is line 2. $ sed -n 's/line 1/*/p' data.txt this is *. w file：将替换的结果输出到file。 $ cat data.txt this is line 1. this is line 2. $ sed 's/line 1/*/w result.txt' data.txt this is *. this is line 2. $ cat result.txt this is *. 替换命令的分隔符/可以换成其他自定义字符： $ cat data.txt this is line 1. this is line 2. $ sed 's,line,number,' data.txt this is number 1. this is number 2. ","date":"2021-06-05","objectID":"/linux_sed/:3:1","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"2. 行寻址 sed默认作用于所有行，如果想指定行号，命令格式为： [address]command 寻址方式有两种： 数字方式。 指定单个行号： $ sed '2s/line/number/' data.txt this is line 1. this is number 2. 指定地址区间： $ sed '1,2s/line/number/' data.txt this is number 1. this is number 2. $表示最后一行： $ sed '1,$s/line/number/' data.txt this is number 1. this is number 2. 文本模式。 $ sed '/line 2/s/line/*/' data.txt this is line 1. this is * 2. 文本模式可以使用正则表达式，具体正则表达式的用法不做说明。 ","date":"2021-06-05","objectID":"/linux_sed/:3:2","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"3. 命令组合 如果想执行多条命令，可以使用分号分隔。 $ sed '1s/line/number/; 1s/is/*/' data.txt th* is number 1. this is line 2. 可以将命令写成多行。 $ sed ' \u003e 1,$s/line/number/ \u003e 1,$s/is/*/ \u003e ' data.txt th* is number 1. th* is number 2. 也可以使用花括号{}将多条命令组合在一起。 $ sed '1,${s/line/number/ ; s/is/*/}' data.txt th* is number 1. th* is number 2. ","date":"2021-06-05","objectID":"/linux_sed/:3:3","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"4. 删除d 可以使用删除命令d删除指定行，删除时也可以使用行寻址。 $ sed '1d' data.txt this is line 2. 使用区间寻址时，第一个匹配模式是打开删除功能，第二个模式是关闭删除功能。 ","date":"2021-06-05","objectID":"/linux_sed/:3:4","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"5. 插入i 插入命令i会在指定行前增加一个新行。 sed '[address]i\\ new line' 如果省略address，则是在每行前增加新行。 ","date":"2021-06-05","objectID":"/linux_sed/:3:5","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"6. 追加a 追加命令a会在指定行后增加一个新行。 sed '[address]a\\ new line' 如果省略address，则是在每行后增加新行。 ","date":"2021-06-05","objectID":"/linux_sed/:3:6","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"7. 修改c 修改命令c可以修改整行的数据内容。 $ sed '2c\\ \u003e this is new line 2' data.txt this is line 1. this is new line 2 如果使用区间寻址，c会对整个区间做替换。 如果省略寻址，则对每行数据做修改。 ","date":"2021-06-05","objectID":"/linux_sed/:3:7","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"8. 转换y 转换命令y可以对单个字符做一对一映射转换。 [address]y/chars1/chars2/ chars1和chars2的长度必须一致，chars1中的字符，会被转换为char2中的字符。 $ sed 'y/hijk/HIJK/' data.txt tHIs Is lIne 1. tHIs Is lIne 2. y是一个全局命令。 ","date":"2021-06-05","objectID":"/linux_sed/:3:8","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"9. 打印命令p 打印命令p和替换标记p类似，可以打印匹配到的数据行。 $ sed -n '1p' data.txt this is line 1. ","date":"2021-06-05","objectID":"/linux_sed/:3:9","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"10. 打印行号 命令=可以打印被匹配数据在文本中的行号。 $ sed '/2/=' data.txt this is line 1. 2 this is line 2. ","date":"2021-06-05","objectID":"/linux_sed/:3:10","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"11. 列出l 列出命令l可以打印匹配数据，包括文本字符和不可打印的转义字符。 ","date":"2021-06-05","objectID":"/linux_sed/:3:11","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"12. 写入命令 w命令可以将匹配数据写入文件。 [address]w filename ","date":"2021-06-05","objectID":"/linux_sed/:3:12","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"13. 读取数据 读取命令r从文件中读取数据，并插入到匹配行后面。 [address]r filename ","date":"2021-06-05","objectID":"/linux_sed/:3:13","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"sed script进阶语法 假设数据文件data.txt为： this is line 1. this is line 2. this is line 3. this is line 4. this is line 5. ","date":"2021-06-05","objectID":"/linux_sed/:4:0","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"1. 模式空间和保持空间 sed在执行命令时，会保存待检查的文本。保存文本，需要用到两个缓冲区，模式空间和保持空间。 执行命令时，读到的数据会保存在模式空间，保持空间主要是起辅助作用。 与缓冲区有关的命令： h: 将模式空间复制到保持空间 H: 将模式空间附加到保持空间 g: 将保持空间复制到模式空间 G: 将保持空间附加到模式空间 x: 交换模式空间和保持空间的内容 ","date":"2021-06-05","objectID":"/linux_sed/:4:1","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"2. 单行数据的next命令 单行next命令会将匹配数据的下一行，移到sed的模式空间，移动前会清空模式空间。 $ sed -n '/line 4/{n; p}' data.txt this is line 5. ","date":"2021-06-05","objectID":"/linux_sed/:4:2","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"3. 多行数据的next命令 多行next命令，会以追加的方式，将匹配行的下一行添加到模式空间。并且，sed会将模式空间中的数据当成一行处理。 $ sed -n '/line 3/{N; p}' data.txt this is line 3. this is line 4. 当要匹配的数据在多行中时，这种语法就能很好的发挥作用。 ","date":"2021-06-05","objectID":"/linux_sed/:4:3","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"4. 多行删除命令D 多行删除命令D，会删除模式空间中的第一行。 注意，d会删除模式空间中的所有数据。 ","date":"2021-06-05","objectID":"/linux_sed/:4:4","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"5. 多行打印命令P 多行打印命令P，会打印模式空间中的第一行。 注意，p会打印模式空间中的所有数据。 ","date":"2021-06-05","objectID":"/linux_sed/:4:5","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"6. 排除命令 排除命令!用于将后续命令作用于非匹配行。 $ sed -n '1,2!p' data.txt this is line 3. this is line 4. this is line 5. ","date":"2021-06-05","objectID":"/linux_sed/:4:6","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"7. 分支命令 分支命令b可以用来改变命令的执行流程。 [address]b [label] address用于寻址，label制定了跳转位置，如果省略label，则跳转到命令脚本的结尾。 $ sed '3b ; s/this is line/*/' data.txt * 1. * 2. this is line 3. * 4. * 5. sed ' \u003e 3b start \u003e s/this is line/*/ \u003e :start \u003e s/this is line/jump/ \u003e ' data.txt * 1. * 2. jump 3. * 4. * 5. ","date":"2021-06-05","objectID":"/linux_sed/:4:7","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"8. 测试命令 测试命令t会根据替换命令的结果，来决定是否跳转到某个标签。 如果没有指定标签，则跳转到命令结尾。 sed ' \u003e s/line 3/*/ \u003e t \u003e s/this is line/*/ \u003e ' data.txt * 1. * 2. this is *. * 4. * 5. ","date":"2021-06-05","objectID":"/linux_sed/:4:8","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"9. 匹配模式 \u0026符号代表替换命令中与模式匹配的文本。 $ echo \"The cat sleeps in his hat.\" | sed 's/.at/\"\u0026\"/g' The \"cat\" sleeps in his \"hat\". 也可以提取替换模式的字模式。 $ echo \"That furry cat is pretty\" | sed 's/furry \\(.at\\)/\\1/' That cat is pretty ","date":"2021-06-05","objectID":"/linux_sed/:4:9","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"sed 示例 ","date":"2021-06-05","objectID":"/linux_sed/:5:0","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"1. 反序输出文本 $ cat data.txt this is line 1. this is line 2. this is line 3. this is line 4. this is line 5. # tac命令可以反序输出 $ tac data.txt this is line 5. this is line 4. this is line 3. this is line 2. this is line 1. # sed也可以反序输出 $ sed -n '1!G; h; $p' data.txt this is line 5. this is line 4. this is line 3. this is line 2. this is line 1. ","date":"2021-06-05","objectID":"/linux_sed/:5:1","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"2. 加倍行距 $ cat data.txt this is line 1. this is line 2. this is line 3. this is line 4. this is line 5. $ sed '/^$/d;$!G' data.txt this is line 1. this is line 2. this is line 3. this is line 4. this is line 5. ","date":"2021-06-05","objectID":"/linux_sed/:5:2","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"3. 给文件的行编号 $ nl data.txt 1 this is line 1. 2 this is line 2. 3 this is line 3. 4 this is line 4. 5 this is line 5. $ cat -n data.txt 1 this is line 1. 2 this is line 2. 3 this is line 3. 4 5 this is line 4. 6 this is line 5. $ sed '=' data.txt | sed 'N; s/\\n/ /' 1 this is line 1. 2 this is line 2. 3 this is line 3. 4 5 this is line 4. 6 this is line 5. ","date":"2021-06-05","objectID":"/linux_sed/:5:3","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"4. 打印末尾行 # 打印最后10行 $ sed ':start; N; 11,$D; b start' data.txt this is line 5. this is line 6. this is line 7. this is line 8. this is line 9. this is line 10. this is line 11. this is line 12. this is line 13. this is line 14. ","date":"2021-06-05","objectID":"/linux_sed/:5:4","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"5. 删除文本中的连续空白行 $ cat data.txt this is line 1. this is line 2. this is line 3. this is line 4. this is line 5. $ sed '/./,/^$/!d' data.txt this is line 1. this is line 2. this is line 3. this is line 4. this is line 5. ","date":"2021-06-05","objectID":"/linux_sed/:5:5","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"6. 删除开头空白行 $ cat data.txt this is line 1. this is line 2. this is line 3. this is line 4. this is line 5. $ sed '/./,$!d' data.txt this is line 1. this is line 2. this is line 3. this is line 4. this is line 5. ","date":"2021-06-05","objectID":"/linux_sed/:5:6","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"7. 删除结尾空白行 $ cat data.txt this is line 1. this is line 2. this is line 3. this is line 4. this is line 5. $ sed ':start; /^\\n*$/{$d; N; b start}' data.txt this is line 1. this is line 2. this is line 3. this is line 4. this is line 5. ","date":"2021-06-05","objectID":"/linux_sed/:5:7","tags":["Linux","sed"],"title":"sed命令详解","uri":"/linux_sed/"}]